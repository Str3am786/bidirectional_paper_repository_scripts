\section{Discussion}\label{s:related_work}

\noindent {\bf Polynomial degree:}
We compare bridging with other accelerations of homomorphic computation at the programming level.
% \vspace{-0.5cm}
As we show in Section \ref{sss:genotype}, the polynomial degree affects the performance and noise budget. A smaller polynomial degree makes operations a few times faster. At the same time, it reduces the noise budget, allowing fewer computations before data corruption or bootstrapping. It also reduces the number of plaintexts that can be packed in a ciphertext when batching. Nevertheless, the performance improvement from a smaller polynomial degree outweighs the fewer batching slots in the ciphertexts.
% The best option is to use the smallest polynomial degree that does not corrupt the ciphertext. 

\noindent {\bf Batching} enables SIMD usage of ciphertexts \cite{batching}. It can provide several orders of magnitude performance improvement for SIMD-compatible applications, however not all FHE schemes support it \cite{chillotti2016faster,ducas2015fhew}. Due to its significant computational benefits, batching should always be used where possible. \iffalse if the target application is compatible with it. \fi

% Unfortunately, not all FHE schemes support batching (e.g., TFHE \cite{chillotti2016faster} and FHEW \cite{ducas2015fhew}). The ones that do, such as BGV \cite{BGV_ref} or BFV \cite{fan2012somewhatmisc}, support it only for some specific encryption parameters, which may not be the most noise efficient parameters for the target application.
% In any case, due to its significant performance benefits, batching should always be used if the target application is compatible with it.

\noindent {\bf Bridging} makes possible to use the comprehensive bit-level arithmetic and the fast modular arithmetic in the same program. It increases the expressivity of programs previously limited to modular arithmetic, and improves performance of complex programs implemented using bit-level arithmetic. At the same time, it reduces noise, since the depth of the datapath is shorter due to fewer homomorphic operations being executed, which may enable using a smaller polynomial degree, further improving performance.
Therefore, the performance improvement provided by bridging comes from two factors: 1) Reduced number of homomorphic operations since Boolean circuits performing additions and multiplications in bit-level arithmetic are replaced by a single operation (native addition or multiplication), and 2) reduced multiplicative depth, since when Boolean circuits are replaced by a single instruction, the multiplicative depth reduces. This reduces the noise budget required by the application, enabling the use of a smaller polynomial degree, further improving performance.
In addition, bridging is independent of encryption parameters, apart from the plaintext modulus which should not be too small. This makes bridging perfectly compatible with batching and any polynomial degree.

% \noindent {\bf Class of programs benefiting from bridging}:
% FHE itself is already introducing restrictions on the class of programs that can be practically used with FHE-encrypted data. Within the subset of applications that have demonstrated such potential, the algorithms that benefit the most from bridging should have all non-native operations at the beginning of computation with the remaining computation using only native operations. This applies well to the algorithms involving data selection followed by computation on selected data. Therefore, examples of such classes of programs are 1) membership tests (case study 1 - URL denylist), 2) information retrieval, 3) set intersections, and 4) keyword search (case study 2 - genotype imputation). On the other hand, algorithms having non-native operations throughout the computation or near its output would not benefit from bridging. This is the case for sorting algorithms, which are mostly comparisons, and some block ciphers algorithms that are heavy on bit-wise operations.