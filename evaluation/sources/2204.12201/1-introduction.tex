\section{Introduction}

With the ever increasing rates of data generation, digital information is becoming extremely valuable over time. As a result, certain types of attacks have emerged, focusing to capitalize on this paradigm shift. To overcome the aforementioned threats, the use of cryptography has been until now the defacto technological security measure to protect against data leakage. Even though accepted standards such as AES have been successful in protecting data-in-transit and data-at-rest, they fail to provide protection towards data-in-use. Hardware solutions \cite{costan2016sgx-explained,trustzone} attempt to provide confidentiality and integrity on sensitive computations, however, a number of attacks \cite{yanga2, hely2012malicious, jin2012exposing, xiao2016hardware, karri2010trustworthy, tsoutsos2013fabrication,adee2008hunt, gross2018ending} including Spectre \cite{Kocher2018spectre}, Meltdown \cite{Lipp2018meltdown}, and Load Value Injection \cite{vanbulck2020lvi}, have raised questions about their effectiveness. Data are eventually decrypted before entering the processor pipeline, and therefore leakage is still possible as recently reported \cite{chen2018sgxpectre}. 

% Consequently, standard encryption algorithms have no effect on data-in-use, as current technology operates exclusively on plaintexts, and therefore requires information to be decrypted before performing any operation on them.

% The latter can be defined as volatile information that is required to undergo certain operations before reaching a state of rest.

% . Intel's software guard extensions (SGX)  and ARM's TrustZone  are two examples of Trusted Execution Environments that allow programmers to protect sensitive data. Even though hardware was believed to be the ultimate root-of-trust, attacks such as Spectre \cite{Kocher2018spectre}, Meltdown \cite{Lipp2018meltdown}, and Load Value Injection \cite{vanbulck2020lvi}, have raised questions about the the validity of this notion.
% Trusted Execution Environments are designed with a fundamental flaw; Data are eventually decrypted before entering the processor pipeline, and therefore leakage is still possible as recently reported \cite{chen2018sgxpectre}


% --------------------
% Along with the AES and other accepted standards, new technologies have also emerged aiming for the improvement of security of data in use. Trusted Execution Environments (TEEs) is one solution that attempts to provide confidentiality and integrity on sensitive computations. As the name implies, TEEs are isolated environments that create the necessary conditions and protection features to securely execute operations. Intel's software guard extensions (SGX) \cite{costan2016sgx-explained} and ARM's TrustZone \cite{trustzone} are two examples of Trusted Execution Environments that allow programmers to protect sensitive data within enclaves, by encrypting all memory traffic in and out of the processor package.

% The appearance of this technology came with a notion that hardware is the ultimate root-of-trust for the software stack. This assumption however, has lately been put at question as attacks such as Spectre \cite{Kocher2018spectre}, Meltdown \cite{Lipp2018meltdown}, and Load Value Injection \cite{vanbulck2020lvi}, keep pilling up. In addition, novel attack trends move closer to the silicon itself. For example, stealthy modifications on hardware designs (i.e., hardware Trojans \cite{yanga2, hely2012malicious, jin2012exposing, xiao2016hardware}), can cause substantial security risks, including privilege escalation, denial of service, information leakage or downgraded performance \cite{karri2010trustworthy, tsoutsos2013fabrication}. Evidently, the lack of hardware-level trust goes beyond academic threat models: There exist folklore reports about a hardware Trojan kill-switch in military air defenses, in the context of electronic warfare \cite{adee2008hunt, gross2018ending}.

% In many contexts, the need for data privacy has been addressed using encryption, which provides implicit access controls to authorized entities with knowledge of a private key. Trusted Execution Environments were once considered a solution to the problem of data security. However, in light of the security threats mentioned above, without end-to-end encryption the privacy risks are merely reduced, but not eliminated. Trusted Execution Environments are designed with a fundamental flaw; Data are eventually decrypted before entering the processor pipeline, and therefore leakage is still possible as recently reported \cite{chen2018sgxpectre}. Consequently, even though encryption can protect data at rest and in transit, protecting \emph{data in use} still remains a challenge.
% %liu2013hardware})

A solution to the problem of protecting data-in-use is Fully Homomorphic Encryption (FHE), as it allows unconstrained computations on ciphertexts. Numerous FHE schemes have been developed, namely BGV~\cite{BGV_ref}, BFV~\cite{fan2012somewhatmisc}, CKKS~\cite{CKKS_ref}, GSW~\cite{GSW_ref}. 
GSW exposes homomorphic Boolean gates and programming computation can be constructed bottom-up.
Such bit-level arithmetic is universal, but requires many Boolean logic operations.
Other schemes, like BGV/BFV, operate directly on integers using modular arithmetic supporting homomorphic addition, subtraction, and multiplication.
At the level of integers however, the operations that can be applied on such ciphertexts are limited to those supported by the encryption scheme.
If an application requires another type of operation like an integer division or comparison, then all computation must be evaluated in bit-level arithmetic, by using arithmetic modulo 2 or algebraic expressions for Boolean gates.

% A solution to the problem of protecting data-in-use is Fully Homomorphic Encryption (FHE), as it allows unconstrained computations on ciphertexts. Since its invention, numerous FHE schemes have been developed, namely BGV~\cite{BGV_ref}, BFV~\cite{fan2012somewhatmisc}, CKKS~\cite{CKKS_ref}, GSW~\cite{GSW_ref}. 
% GSW exposes homomorphic Boolean gates and programming computation can be constructed bottom-up.
% Such bit-level arithmetic is universal, but requires many Boolean logic operations even for addition or multiplication of two numbers.
% Other schemes, like BGV/BFV, operate directly on integers using modular arithmetic supporting homomorphic addition, subtraction, and multiplication.
% At the level of integers, however, the operations that can be applied on such ciphertexts are limited to those supported by the encryption scheme.
% If an application requires another type of operation like an integer division or comparison, then all computation must be evaluated in bit-level arithmetic, by using arithmetic modulo 2 or algebraic expressions for Boolean gates.

% Immediately after its inception in 2009,

In 2009, FHE received criticism on its high computational overheads, which made it challenging at the time to employ in practical applications. Improvements have since been performed on various fronts: 1) Improvement of implementation of FHE libraries. For example, HElib was recently overhauled to achieve almost $75 \times$ performance improvement \cite{cryptoeprint:2018:244}; 2) Hardware acceleration. The developers of nuFHE \cite{nuFHE} report about $100 \times$ acceleration over the software-based implementation of TFHE using GPU hardware. Meanwhile, F1, an ASIC accelerator for the BGV encryption scheme, outperforms software implementations by $5,400 \times$ \cite{f1}; 3) Dedicated programming frameworks. These frameworks allow users to express programming intent directly in a general-purpose programming language, such as Go, Python, C++.
For example, Lattigo~\cite{lattigop} implements  BFV and CKKS schemes in the Go programming language.
PyFHE, PySEAL and Pyfhel~\cite{pyfhel} are frameworks providing Python interface to FHE operations.
\eee\ framework \cite{e3eprint} offers custom C++ data types that can abstract the complexity of FHE library operations. As we observe, native modular arithmetic must be used for logic bit operations; hence program variables must be represented as a sequences of encrypted bits. In such case, \textit{all} programming operations are performed by evaluating Boolean circuits working on encrypted bits - ciphertexts. This transformation makes all computational operations slow, including addition and multiplication.
% Commented out by Homer 
% Nevertheless, in the past decade significant improvements have been made that lead to improvements of several orders of magnitude
% : they are evaluated as Boolean circuits consisting of many gates and each gate operation is composed of modular operations in the direct modular computation. 

\innersection{Our contribution}
In this work, our proposal is to leverage the properties of both (1) bit-level arithmetic (universal, but slower) and (2) modular arithmetic (faster, but not universal) within the same algorithm expressed as a C++ program with custom data types, which allows much better performance of general-purpose programs processing encrypted data. 
Towards that end, we extend the E3 programming framework \cite{e3eprint} and implement \emph{Bridging}, which enables the mixing of different arithmetic abstractions in the same C++ program that processes FHE data.
The benefit of using our method is a significant application performance improvement, as we demonstrate with our experiments.

% \innersection{Paper roadmap}
% Section \ref{s:preliminaries} introduces key concepts of homomorphic encryption, data-oblivious programming, and FHE schemes. In Section \ref{s:bridging}, we present our proposal and demonstrate how bridging can significantly improve the performance of FHE applications. Experimental results are evaluated in Section \ref{s:results} with synthetic benchmarks and real-world applications. Related work is available in Section \ref{s:related_work}. Finally, in Section \ref{s:conclusions}, we conclude our paper with the main insights.