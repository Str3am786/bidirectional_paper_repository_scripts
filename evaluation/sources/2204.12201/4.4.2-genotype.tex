% \subsubsection{Genotype imputation}\label{sss:genotype}
\subsection{Case-study: Genotype imputation}\label{sss:genotype}

Genotype imputation is the process of filling missing information in DNA sequencing with the use of statistical methods. \iffalse Due to the computer-intensive nature of the task, cloud servers are a natural platform for processing the data. Furthermore, privacy requirements of medical information make solutions using homomorphic encryption desirable. \fi P-Impute \cite{GURSOY2021} converts an inefficient statistical model based on correlation of similar individuals %\footnote{The similarity of individuals is determined based on matching single-nucleotide polymorphisms (SNPs) in proximity to the missing SNP.}
into a Private Information Retrieval (PIR) problem, which has efficient solutions in FHE, using the BFV encryption scheme. In this section, we discuss the performance of p-Impute without (\secuint) and with bridging taking into consideration the multiplicative depth for defining more efficient encryption parameters. Batching is used to fit $n$ plaintexts into a ciphertext.

% As this application has much higher memory requirements compared to the previous experiments, we ran the experiments on an Intel Xeon Silver 4214R CPU @ 2.40GHz with 24 cores and 1 TB of memory running on RHEL 7.9. We use the same version of E3 and Microsoft SEAL as in the other experiments with GCC 7.3.1.
We set each run to use 24 threads and report the query time, i.e., the time performing encrypted computation, and the number of ciphertext additions, multiplications, and subtractions in Table \ref{tab:nops}. We use the same plaintext modulus as in the other experiments ($t = 2^{16}+1$), but we vary the polynomial degree ($n \in \{2^{13}, 2^{14}, 2^{15}\}$) in order to evaluate the extra performance improvement provided by bridging for requiring a lower multiplicative depth.
Without bridging, we were only able to run with $n = 2^{15}$, since lower polynomial degrees do not provide enough noise budget to run the application without bootstrapping. %\footnote{Bootstrapping is not supported by Microsoft SEAL library. Accounting for noise growth is commonly tasked to the programmer in FHE applications.}
With bridging, we were able to reduce $n$ to $2^{13}$ without corrupting the result.
As $n$ reduces, the number of batching slots in a ciphertext reduces since it is equal to the polynomial degree. However, the reduction in latency for the homomorphic operation compensates for the reduction in slots. Experimental results show that when $n$ is halved, the latency of the ciphertext multiplication reduces by at least 4 times, and can be amplified depending on the behavior of cache memories. \iffalse This effect can be even greater due to effects related to cache memories.  Therefore, reducing the polynomial degree is always desirable.\fi Consequently, one halving of $n$ increases throughput by at least 2x and reduces latency by 4x.

For the same polynomial degree ($n = 2^{15}$), bridging is around 6.82x faster than bit-level arithmetic. This is due to the reduced number of operations on encrypted data, as one can see in Table \ref{tab:nops}.
Nevertheless, bridging requires less noise budget to operate, which allows us to use smaller polynomial degrees. In the fastest case, bridging has the throughput improved by 62.2x, while the latency reduces by around 249 times.
\vspace{-0.1cm}
\input{table/nops}
