\section{Introduction}
Source code refactoring, which consists in improving the internal structure of the code while keeping its external behaviour unchanged, represents a substantial portion of software maintenance activities.
To help practitioners in identifying where -- and what kind of -- refactoring should be applied in software systems, the concept of \textit{design smells} has been introduced and defined by Fowler~\cite{Fowler1999} as symptoms of poor solutions to recurring design problems. These symptoms, also called \textit{anti-patterns}, are typically introduced in object-oriented systems when developers implement sub-optimal design solutions due to lack of knowledge and--or time constraints. For example, the God Class anti-pattern refers to the situation in which a class grows rapidly by the addition of new functionalities, when developers break the principle of single responsibility. Prior empirical studies highlighted the negative impact of anti-patterns on a variety of quality characteristics, such as program comprehension~\cite{abbes2011empirical}, maintainability~\cite{yamashita2013exploring}, and correctness (increase of fault-proneness)~\cite{khomh2012exploratory}. Thus, it is important to identify their occurrences in systems and apply refactoring operations to remove them.

Several approaches have been proposed to detect the occurrences of anti-patterns in source code. Most of these approaches attempt to identify bad motifs in models of source code using manually-defined heuristics that rely on some metrics (e.g., cyclomatic complexity). For example, Moha et al.~\cite{Moha10-TSE-DECOR} proposed a domain-specific language to describe and generate detection algorithms for anti-patterns using structural and lexical metrics while Palomba et al.~\cite{PalombaBPOLP13,Palomba15} proposed a rule-based approach to detect anti-patterns from change history information.

Even though these approaches have shown acceptable performances, none of them can claim high accuracy on any systems and for any anti-patterns. Besides, each approach relies on its own definitions of anti-patterns and only focuses on specific aspects of systems. Thus, we observe a complementarity among the different approaches, especially when they rely on orthogonal sources of information (e.g., structural vs. historical) \cite{fontana2012automatic, PalombaBPOLP13}.

Consequently, we propose SMAD (SMart Aggregation of Anti-patterns Detectors), a machine-learning based ensemble method to combine various anti-patterns detection approaches in order to achieve better performances. Hence, our approach aims at reducing software maintenance costs by helping practitioners in identifying more accurately the code components to be refactored. Concretely, for each approach to be aggregated, we identify a set of core metrics, i.e., metrics that reflect the internal detection rule of the approach. We then use the core metrics as input features of a neural-network classifier. To the best of our knowledge, we are the first to propose an ensemble method in the context of anti-patterns detection.

Recently, machine-learning models have been shown efficient in a variety of domains, such as speech recognition~\cite{graves2013speech} or image processing~\cite{krizhevsky2012imagenet}. Several machine-learning based approaches have been proposed to detect anti-patterns. However, these approaches failed to surpass clearly conventional techniques. On the one hand, learning high-level features of systems requires complex machine-learning models, such as deep-neural-networks. On the other hand, these complex models require substantial amounts of manually-produced training data, which is hardly available and time consuming to produce for anti-patterns.

On the contrary our method relies on existing approaches which allows our model to take as input a low number of high-level key features (i.e.,  the core metrics). As a consequence, our method can benefit from a simple machine-learning classifier that requires a reasonable number of training examples. We implemented the proposed ensemble method to detect two well known anti-patterns: God Class and Feature Envy. To conduct our experiments, we created an oracle containing occurrences of the studied anti-patterns in eight Java systems. 

This paper thus makes the following contributions: (1) a manually-produced oracle reporting the occurrences of God Class and Feature Envy in eight Java software systems; (2) a machine learning-based ensemble method to aggregate existing anti-patterns detection approaches.

The remainder of this paper is organized as follows. Section~\ref{section: related work} defines the two anti-patterns considered in this study and discusses the related work. Section~\ref{section: smad} describes our approach \NAME{}. Section~\ref{section: methodology} presents our data as well as preliminary considerations for our study. Section~\ref{section: evaluation performances} reports the results of our study aiming to evaluate the performances of our method as well as to compare it with other approaches. Section~\ref{section: threats} discusses the threats that could affect the validity of our results. Finally, Section~\ref{section: conclusion} concludes and discusses future work.