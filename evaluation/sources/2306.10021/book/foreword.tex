%%%%%%%%%%%%%%%%%%%%%%foreword.tex%%%%%%%%%%%%%%%%%%%%%%%%%%%
% sample foreword
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%

\foreword

Emacs or vi(m)? Even with the integration of Visual Studio Code (VSCode) inside GitHub, there is no end in sight for the quintessential editor wars. Since the mid '80s, thousands of online, mostly futile, discussions and flamewars have focused on which editor is the best for coding and other text processing tasks. At the surface level, this long-standing debate seems to focus merely on factors like the graphical user interface of the editors, modal vs. chord-based keyboard handling, or availability of the editors on a variety of operating systems. 

However, to actual users of these tools the choice for a given editor really is based on two key criteria: (1) the ability to customize the editor to their specific workflow via third-party, open-source extensions (or: ``plugins''); and (2) a sense of community and belonging amongst users and providers of third-party extensions. Extensibility is built into each of these editors via an underlying scripting language (from Emacs' underlying Lisp interpreter and vim's Vim script, to VSCode's TypeScript) and a dedicated plugin API. These two elements aim to seamlessly blend default functionality shared by all users (basic text manipulation) with highly custom functionality of interest to a fraction of the userbase (support for different versioning control systems, advanced text completion mechanisms, etc.). At the time of writing this foreword (March 2023), the popular MELPA package archive\footnote{\url{https://melpa.org}} (one of several archives for Emacs) lists 5,391 plugins, \url{vim.org} 5,888 vim plugins, and the VSCode Marketplace\footnote{\url{https://marketplace.visualstudio.com}} even 44,330 extensions!

These extensions do not come out of thin air, but build on each other, both in terms of technical dependencies and underlying ideas, based on strong interactions between communities of extension developers, users and enthusiasts. Dedicated fora on reddit or Stack Overflow feature thousands of enthusiasts exchanging ideas, workflow suggestions, ad hoc customizations, bug fixes and plans for future extensions. Furthermore, GitHub is rife with people sharing their personal configuration files (``emacs configuration'' resulted in 6,480 hits), or even standardizing them into official, supported distributions or variants of their editor (e.g., Doom Emacs or Prelude Emacs). Code contributed by such distributions as well as individual extensions can then be picked up by the developer community of the underlying editor, making its way into the upstream project. Apart from code contributions, artists also chime in to submit new themes or styles to tailor the visual aspects of their favourite editor.

In other words: each editor has its own {\em software ecosystem}, essentially consisting of a base technology (the editor itself), technical components (the editor extensions) depending on that technology and each other, and social interactions between each component's communities. As such, the point of the editor wars is not about choosing the ``best'' base technology, but about buying into the ``best'' editor ecosystem, where the definition of ``best'' refers to health-related measures such as the sustainability of an ecosystem, the absence of longstanding bugs, the rate of innovation as well as the degree to which the values of the ecosystem's community match with those of a given user.

In that respect, the so-called editor wars are actually not that different from ``competition'' between other ecosystems, such as mobile app frameworks and their respective app stores (\eg iOS versus Android ecosystems), programming languages with their third-party library support (e.g., Javascript's npm vs. Java's Maven Central ecosystems), open source Linux distributions (e.g., Fedora vs. Ubuntu ecosystems) or even software infrastructure technologies (e.g., Docker Hub vs. Kubernetes). In all these cases it is not about the base technology or product, it is all about the community, technical interactions and value creation surrounding these.

\bigskip
This seamlessly brings us to the topic of this book: given a software ecosystem, how can one measure and monitor its health, innovation, value, etc. in a consistent and effective manner? What kinds of data sources are available to gauge an ecosystem's development practices, evolution and internal conflicts, both amongst ecosystem contributors or between competing ecosystem projects? How can this data be obtained, cleaned and preprocessed? What kinds of analyses should be performed, and which models could be used? How to interpret the resulting findings, and how can they impact the state-of-the-practice of software ecosystems?

For one, these questions address the essential concerns practitioners have when trying to select the right ecosystem for their business, to plan maintenance activities, or to identify important health risks that might impact (parts of) their ecosystems. This is very clear from current initiatives like the Linux Foundation's CHAOSS project\footnote{\url{https://chaoss.community}}, which stands for ``Community Health Analytics in Open Source Software''. Together with industry, various CHAOSS working groups have developed a catalog of (thus far) 79 health metrics at the level of individual software projects, only 9 of which catch some aspect of health at the ecosystem level. Hence, in order to get insights in new ecosystem-level health metrics and to automate their measurement, this book is indispensable.

At the same time, researchers and students need to learn about the state-of-the-art in this domain in order to study ever more challenging software ecosystem topics. What has attracted me to this research domain, and also led me to participate in an international research project on ecosystem health with researchers of Wallonia (Belgium) and Quebec (Canada), is the need for interdisciplinary research. Research labs in sociology, biology, information sciences, etc. have developed highly sophisticated theories and metaphors that provide unique perspectives on ecosystem health. Yet, these labs lack the software engineering and software analytics backgrounds required to empirically validate such theories. Again, a book like this one prepares the reader for exactly this purpose.

Finally, what will the future bring to the domain of software ecosystems and its researchers? Similar to how software ecosystems are more than just a set of individual open source projects, ecosystems of ecosystems are more than just an agglomeration of individual ecosystems. Going back to our example ecosystem of editors, the recent breakthrough of Microsoft's language server protocol (LSP) has shown ways in which innovation not only propagates from one ecosystem (VS Code) to its competing ecosystems, but also that it can spawn a new, interacting ecosystem of language servers as a side-effect. Such meta-phenomena can have disruptive side-effects on software ecosystems, hence necessitating thorough empirical research.

At the same time, it will be fascinating to understand how the role of AI will impact existing ecosystems. While, thus far, ecosystem communities consist of actual humans assisted by bots for rote automation of tedious tasks, the introduction of AI agents whose contributions might be hard to distinguish from human contributions, has the potential to disrupt or even sabotage today's ecosystem dynamics. Once more, the advent of AI in software ecosystems provides another major opportunity to validate existing theories of ecosystem dynamics using the techniques presented by this book.

\vspace{\baselineskip}
\begin{flushright}\noindent
  Kingston,\hfill {\it Bram  Adams}\\
  Ontario (Canada),\hfill (proud user of the \\
  March 2023\hfill Emacs ecosystem)
\end{flushright}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../book"
%%% End:
