{"somef_provenance": {"somef_version": "0.9.4", "somef_schema_version": "1.0.0", "date": "2023-12-21 18:55:57"}, "code_repository": [{"result": {"value": "https://github.com/AdaptiveCpp/AdaptiveCpp", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "owner": [{"result": {"value": "AdaptiveCpp", "type": "Organization"}, "confidence": 1, "technique": "GitHub_API"}], "date_created": [{"result": {"value": "2018-07-15T00:12:40Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "date_updated": [{"result": {"value": "2023-12-21T09:53:24Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "license": [{"result": {"value": "https://api.github.com/licenses/bsd-2-clause", "type": "License", "name": "BSD 2-Clause \"Simplified\" License", "url": "https://api.github.com/licenses/bsd-2-clause", "spdx_id": "BSD-2-Clause"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "\nCopyright (c) 2018 Aksel Alpay\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/LICENSE"}, {"result": {"value": "The MIT License (MIT)\n\nCopyright (c) 2017 Facebook Inc.\nCopyright (c) 2017 Georgia Institute of Technology\nCopyright 2019 Google LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/include/hipSYCL/sycl/libkernel/detail/fp16/LICENSE"}], "description": [{"result": {"value": "Implementation of SYCL and C++ standard parallelism for CPUs and GPUs from all vendors: The independent, community-driven compiler for C++-based heterogeneous programming models. Lets applications adapt themselves to all the hardware in the system - even at runtime!", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Text_excerpt", "value": "AdaptiveCpp is the independent, community-driven modern platform for C++-based heterogeneous programming models targeting CPUs and GPUs from all major vendors. AdaptiveCpp lets applications adapt themselves to all the hardware found in the system. This includes use cases where a single binary needs to be able to target all supported hardware, or utilize hardware from different vendors simultaneously. \nIt currently supports the following programming models:\n1. **SYCL**: At its core is a SYCL implementation that supports many use cases and approaches of implementing SYCL. \n2. **C++ standard parallelism**: Additionally, AdaptiveCpp features experimental support for offloading C++ algorithms from the parallel STL. See [here](doc/stdpar.md) for details on which algorithms can be offloaded. **AdaptiveCpp is currently the only solution that can offload C++ standard parallelism constructs to GPUs from Intel, NVIDIA and AMD -- even from a single binary.** \n1. **A generic, single-pass compiler infrastructure that compiles kernels to a unified code representation** that is then lowered at runtime to target devices, providing a high degree of portability, low compilation times, flexibility and extensibility. **AdaptiveCpp is the only major SYCL implementation that supports a single-pass compiler design, where the code is only parsed once for both host and target devices**. Support includes:\n   1. NVIDIA CUDA GPUs through PTX;\n   2. AMD ROCm GPUs through amdgcn code;\n   3. Intel GPUs through SPIR-V (Level Zero);\n   4. SPIR-V compatible OpenCL devices supporting Intel USM extensions or fine-grained system SVM (such as Intel's OpenCL implementation for CPUs or GPUs)\n2. Additionally, **AdaptiveCpp can aggregate existing clang toolchains and augment them with support for SYCL constructs**. This allows for a high degree of interoperability between SYCL and other models such as CUDA or HIP. For example, in this mode, the AdaptiveCpp CUDA and ROCm backends rely on the clang CUDA/HIP frontends that have been augmented by AdaptiveCpp to *additionally* also understand other models like SYCL. This means that the AdaptiveCpp compiler can not only compile SYCL code, but also CUDA/HIP code *even if they are mixed in the same source file*, making all CUDA/HIP features - such as the latest device intrinsics - also available from SYCL code ([details](doc/hip-source-interop.md)). Additionally, vendor-optimized template libraries such as rocPRIM or CUB can also be used with AdaptiveCpp. This allows for highly optimized code paths in SYCL code for specific devices. Support includes:\n   1. Any LLVM-supported CPU (including e.g. x86, arm, power etc) through the regular clang host toolchain with dedicated compiler transformation to accelerate SYCL constructs;\n   2. NVIDIA CUDA GPUs through the clang CUDA toolchain;\n   3. AMD ROCm GPUs through the clang HIP toolchain;\n   4. Intel GPUs through oneAPI Level Zero and the clang SYCL toolchain (*highly* experimental, deprecated)\n3. Or **AdaptiveCpp can be used in library-only compilation flows**. In these compilation flows, AdaptiveCpp acts as a C++ library for third-party compilers. This can have portability advantages or simplify deployment. This includes support:\n   1. Any CPU supported by any OpenMP compilers;\n   2. NVIDIA GPUs through CUDA and the NVIDIA nvc++ compiler, bringing NVIDIA vendor support and day 1 hardware support to the SYCL ecosystem \nBecause a program compiled with AdaptiveCpp appears just like any other program written in vendor-supported programming models (like CUDA or HIP) to vendor-provided software, vendor tools such as profilers or debuggers also work well with AdaptiveCpp. \nAn illustration on how the project fits into the SYCL ecosystem can be found ([here](doc/sycl-ecosystem.md)).\n \n", "original_header": "AdaptiveCpp (formerly known as hipSYCL / Open SYCL)"}, "confidence": 0.971523541651875, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "While AdaptiveCpp started its life as a hobby project, development is now primarily led and funded by Heidelberg University, with contributions from the community. AdaptiveCpp not only serves as a research platform, but is also a solution used in production on machines of all scales, including some of the most powerful supercomputers.\n \n", "original_header": "About the project"}, "confidence": 0.9969643589545604, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "AdaptiveCpp has been repeatedly shown to deliver very competitive performance compared to other SYCL implementations or proprietary solutions like CUDA. See for example: \n", "original_header": "Performance"}, "confidence": 0.8325397755866998, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "* For strong-scaling/latency-bound problems, the alternative instant task submission mode can be used, which can substantially lower task launch latencies. Define the macro `HIPSYCL_ALLOW_INSTANT_SUBMISSION=1` before including `sycl.hpp` to enable it. Instant submission is possible with operations that do not use buffers (USM only), have no dependencies on non-instant tasks, do not use SYCL 2020 reductions and use in-order queues. In the stdpar model, instant submission is active by default.\n* Building AdaptiveCpp against newer LLVM generally results in better performance for backends that are relying on LLVM.\n* Unlike other SYCL implementations that may rely on kernel compilation at runtime, some compilation flows in AdaptiveCpp rely heavily on ahead-of-time compilation. So make sure to use appropriate optimization flags when compiling.\n* For the CPU backend:\n   * Don't forget that, due to AdaptiveCpp's ahead-of-time compilation nature, you may also want to enable latest vectorization instruction sets when compiling, e.g. using `-march=native`.\n   * Enable OpenMP thread pinning (e.g. `OMP_PROC_BIND=true`). AdaptiveCpp uses asynchronous worker threads for some light-weight tasks such as garbage collection, and these additional threads can interfere with kernel execution if OpenMP threads are not bound to cores.\n   * When using `OMP_PROC_BIND`, there have been observations that performance suffers substantially, if AdaptiveCpp's OpenMP backend has been compiled against a different OpenMP implementation than the one used by `acpp` under the hood. For example, if `omp.acclerated` is used, `acpp` relies on clang and typically LLVM `libomp`, while the AdaptiveCpp runtime library may have been compiled with gcc and `libgomp`. The easiest way to resolve this is to appropriately use `cmake -DCMAKE_CXX_COMPILER=...` when building AdaptiveCpp to ensure that it is built using the same compiler. **If you oberve substantial performance differences between AdaptiveCpp and native OpenMP, chances are your setup is broken.**\n   * Don't use `nd_range` parallel for unless you absolutely have to, as it is difficult to map efficiently to CPUs. \n      * If you don't need barriers or local memory, use `parallel_for` with `range` argument.\n      * If you need local memory or barriers, scoped parallelism or hierarchical parallelism models may perform better on CPU than `parallel_for` kernels using `nd_range` argument and should be preferred. Especially scoped parallelism also works well on GPUs.\n      * If you *have* to use `nd_range parallel_for` with barriers on CPU, the `omp.accelerated` compilation flow will most likely provide substantially better performance than the `omp.library-only` compilation target. See the [documentation on compilation flows](doc/compilation.md) for details.\n* For performance in the C++ parallelism model specifically, see also [here](doc/stdpar.md).\n \n", "original_header": "General performance hints"}, "confidence": 0.991074939642459, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "When targeting the CUDA or HIP backends, AdaptiveCpp just massages the AST slightly to get `clang -x cuda` and `clang -x hip` to accept SYCL code. AdaptiveCpp is not involved in the actual code generation. Therefore *any significant deviation in kernel performance compared to clang-compiled CUDA or clang-compiled HIP is unexpected.* \n", "original_header": "Comparing against other LLVM-based compilers"}, "confidence": 0.902068205258485, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "AdaptiveCpp is not yet a fully conformant SYCL implementation, although many SYCL programs already work with AdaptiveCpp.\n* SYCL 2020 [feature support matrix](https://github.com/hipSYCL/featuresupport)\n* A (likely incomplete) list of [limitations](doc/limitations.md) for older SYCL 1.2.1 features\n* A (also incomplete) timeline showing development [history](doc/history.md)\n \n", "original_header": "Current state"}, "confidence": 0.9868188973958484, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "name": [{"result": {"value": "AdaptiveCpp", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "full_name": [{"result": {"value": "AdaptiveCpp/AdaptiveCpp", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "issue_tracker": [{"result": {"value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/issues", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "forks_url": [{"result": {"value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/forks", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "stargazers_count": [{"result": {"value": 899, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "keywords": [{"result": {"value": "adaptivecpp, compiler, gpgpu, gpu-computing, high-performance, high-performance-computing, hipsycl, hpc, opensycl, stdpar, sycl", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "forks_count": [{"result": {"value": 145, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "download_url": [{"result": {"value": "https://github.com/illuhad/hipSYCL/releases", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "programming_languages": [{"result": {"value": "C++", "name": "C++", "type": "Programming_language", "size": 3810874}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "CMake", "name": "CMake", "type": "Programming_language", "size": 98249}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Shell", "name": "Shell", "type": "Programming_language", "size": 72683}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Python", "name": "Python", "type": "Programming_language", "size": 72571}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "C", "name": "C", "type": "Programming_language", "size": 861}, "confidence": 1, "technique": "GitHub_API"}], "releases": [{"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/127279259", "tag": "v23.10.0", "name": "AdaptiveCpp 23.10.0", "author": {"name": "illuhad", "type": "User"}, "description": "# Highlights\r\n\r\nThis release contains several major features, and introduces a major shift in the project's capabilities:\r\n\r\n* **New project name: AdaptiveCpp**. This release is the first release with the new name, and contains renamed, user-facing components. This includes e.g. renamed compiler (`acpp`), compiler flags (e.g. `--acpp-targets`), cmake integration and more. The old name is still supported for backward compatibility during a transitional period. For details on why this renaming occured, see https://github.com/AdaptiveCpp/AdaptiveCpp/issues/1147\r\n* **The world's first single-pass SYCL compiler (`--acpp-targets=generic`):** This release is the first release to contain our new single-pass compiler. This is the world's only SYCL compiler which does not need to parse the code multiple times to generate a binary. Instead, during the regular host compilation, LLVM IR for kernels is extracted and embedded in the binary. At runtime, this IR is then JIT-compiled to whatever is needed (currently supported is PTX, amdgcn and SPIR-V)\r\n   * As such, this new compiler design is also the first SYCL compiler to introduce a **unified code representation across backends**\r\n   * **\"Compile once, run anywhere\"** -  the new design guarantees that every binary generated by `acpp --acpp-targets=generic` can directly be executed on all supported GPUs from Intel, NVIDIA and AMD. The new approach can **dramatically reduce compile times**, especially when many devices need to be targeted since the code still is only parsed a single time.\r\n   * See the paper for more details: https://dl.acm.org/doi/10.1145/3585341.3585351\r\n* The **world's first SYCL implementation to support automatic offloading of C++ parallel STL algorithms (`--acpp-stdpar`)**. This heterogeneous programming model was until now primarily supported by NVIDIA's nvc++ for NVIDIA GPUs. AdaptiveCpp not only supports it for NVIDIA, AMD and Intel GPUs, but also conveniently allows to generate a binary that can dispatch to all supported devices using the new single-pass compiler. See here for details on this new experimental feature: https://github.com/AdaptiveCpp/AdaptiveCpp/blob/develop/doc/stdpar.md\r\n* **Production support for Intel GPUs** through the new single-pass compiler\r\n* **New OpenCL backend** - this new backend supports targeting OpenCL SPIR-V devices, such as Intel's CPU and GPU OpenCL runtimes, bringing the total number of supported backends to five.\r\n* Many bug fixes and performance optimizations!\r\n\r\n\r\n## What's changed\r\n\r\nThe full list of changes it too long for release pages; please see here for a comprehensive list of all changes:\r\n**Full Changelog**: https://github.com/AdaptiveCpp/AdaptiveCpp/compare/v0.9.4...v23.10.0\r\n\r\n## New Contributors\r\n* @RaulPPelaez made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/967\r\n* @Momellouky made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1017\r\n* @tdavidcl made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/965\r\n* @tom91136 made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1065\r\n* @0dminnimda made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1080\r\n* @eirrgang made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1069\r\n* @jamesreinders made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1157\r\n* @bashbaug made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1163\r\n* @karolherbst made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1177\r\n* @Calandracas606 made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1204\r\n* @gogo2 made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1209\r\n\r\n", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v23.10.0", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v23.10.0", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v23.10.0", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/127279259", "release_id": 127279259, "date_created": "2023-10-30T20:51:14Z", "date_published": "2023-10-31T15:23:49Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/125786932", "tag": "v23.10.0-alpha", "name": "AdaptiveCpp 23.10.0 alpha prerelease", "author": {"name": "illuhad", "type": "User"}, "description": "This is a prerelease for the upcoming 23.10.0 to provide a testing target.\r\n\r\n## What's Changed (incomplete, see full changelog below)\r\n* Add generic SSCP compilation flow: Single pass compiler to generic LLVM IR + runtime JIT by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/862\r\n* [SSCP][NFC] Update installation requirements for SSCP by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/904\r\n* [Doc] Update install-llvm.md by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/905\r\n* Update Level Zero installation instructions by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/906\r\n* [SSCP][L0] Avoid passing nullptr as pointee value to zeKernelSetArgumentValue by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/910\r\n* [SSCP] Handle llvm.lifetime.start/end intrinsic when moving allocas to different AS by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/911\r\n* [SSCP][llvm-to-spirv] Handle freeze instruction, which is unsupported by llvm-spirv translator by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/914\r\n* [SSCP] Avoid spilling function pointer type into SSCP IR due to host barrier pointer in nd_item by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/913\r\n* [SSCP][llvm-to-ptx] Respect NVVM wanting alloca instructions in addrspace 0 by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/915\r\n* [SSCP] Avoid using typeid in LLVMToBackend to allow RTTI-less LLVM by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/920\r\n* Fix API compat with LLVM 16 ToT. by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/918\r\n* [SSCP] Remove stack protection attributes in device code by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/922\r\n* [SSCP] Handle global variable address spaces by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/921\r\n* Add comparison operators to test if `multi_ptr == nullptr` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/924\r\n* install-rocm.md: Problem with ROCm 5.0 and SSCP by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/927\r\n* Explicitly convert paths to `std::string`  by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/926\r\n* Bump version to 0.9.4 by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/928\r\n* [SSCP] Use information from llvm::DataLayout to correctly calculate parameter offset in kernel lambda by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/925\r\n* Resolve -Wpessimizing-move warning by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/931\r\n* [SSCP][llvm-to-spirv] Add support for pointer wrapping by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/930\r\n* [SSCP][llvm-to-spirv] Enable Intel llvm-spirv translator extensions by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/932\r\n* [SSCP] Enable aggressive inlining for all backends by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/933\r\n* [doc] Mention that the repositories are outdated. by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/935\r\n* Fix parsing backend string by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/936\r\n* [doc] Fix formatting of compilation flow documentation by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/938\r\n* Update `sycl::vec` class to reflect SYCL 2020 requirements  by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/907\r\n* [Renaming][NFC] Change logo and top-level readme by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/943\r\n* [Renaming][NFC] Update SYCL implementations image by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/947\r\n* [Renaming] Fix CI paths by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/944\r\n* Logo: Add text-to-path version of logo, and double check image size by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/946\r\n* [Renaming][NFC] Update documentation hipSYCL->Open SYCL by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/950\r\n* [Renaming] Remove internal syclcc references to hipSYCL; accept Open SYCL arguments by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/948\r\n* [SYCL 2020] Initial marray implementation by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/884\r\n* [Renaming] Rename all targets containing hipSYCL except for hipSYCL-rt by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/951\r\n* Generic half (fp16) support by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/885\r\n* Add half int constructor by @normallytangent in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/957\r\n* Change sycl::noinit to sycl::no_init by @RaulPPelaez in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/967\r\n* Tweaks and fixes for math built-ins by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/960\r\n* Add type aliases `halfn = vec<half, n>` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/970\r\n* [SSCP] Fix sinpi/cospi builtins for SPIR-V targets by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/975\r\n* [SSCP] Add atomic support by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/941\r\n* [CI] Add LLVM 16. by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/980\r\n* [Renaming] Support new name in cmake integration by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/958\r\n* [half] Add numeric_limits and hash for half by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/984\r\n* [CI] Update to version 22.11 of the Nvidia HPC SDK by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/986\r\n* [SSCP][CI] Add SSCP compile testing to CI by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/981\r\n* [SSCP] Do not use OpenMP CXX flags/link line by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/988\r\n* Append environment variable for flags in syclcc by @normallytangent in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/982\r\n* Addendum to #832 for CUDA/HIP devices by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/989\r\n* Add operators for +,-,*,/ for `half` with other scalar types by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/969\r\n* [CI] Fix CI for forks still using hipSYCL as repo name \ud83d\ude07  by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/995\r\n* Add isfinite, isinf, isnormal and signbit relational built-ins by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/959\r\n* [Doc] Tweak instructions to build w/ LLVM by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/937\r\n* Remove Ubuntu 18.04 from CI by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/997\r\n* [CBS] Fix creating wi-loop for barrier-free kernel, if the kernel has\u2026 by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/998\r\n* [CBS] Dynamically sized stack arrays. by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/994\r\n* Check number of `Args...` of `vec` constructor in template parameter to allow SFINAE by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/954\r\n* Add -DWITH_SSCP_COMPILER=OFF to minimal install script by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1009\r\n* [Doc] Fix (very) minor spelling/grammar mistakes by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1011\r\n* [Doc] fix a very minor typo by @Momellouky in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1017\r\n* [L0] Resolve API failures for USM pointer queries by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1021\r\n* Implement math builtin frexp, modf, sincos by @fxzjshm in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1007\r\n* Add a few missing operators to `id` class by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1018\r\n* Add `buffer(Container)` constructor by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/990\r\n* [SSCP] Fix S2 compilation for globals without initializer by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1020\r\n* [NFC] Add new publications to readme by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1026\r\n* Add missing operators for `range` class by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1027\r\n* Fix Windows GitHub CI by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/977\r\n* [LLVM] Fix compat with upstream LLVM by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1003\r\n* [SSCP] Fix SSCP issues for LLVM 17 by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1028\r\n* [CI] Tidy up and test with ubuntu 22.04 by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1004\r\n* [CI] Fix Windows CI (again) by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1032\r\n* [CI] Add GPU-based workflows & testing to CI by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1029\r\n* Implement SYCL2020 accessor offset semantics by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/992\r\n* [SYCL2020] Migrate information descriptors to their respective namespaces by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/987\r\n* Add ldexp math built-in by @nmnobre in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/962\r\n* add clz builtin by @tdavidcl in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/965\r\n* Add unary +/- operators for `half` by @normallytangent in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1038\r\n* Fix CMake warnings by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1041\r\n* Expose `Dimensions` template paramter for `{nd_}range`, `{nd_,h_}item` and `id` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1016\r\n* Allow non-default-construbtible types for `buffer(Container)` and `buffer(Iterator, Iterator)` constructors  by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1033\r\n* [CI] Remove superfluous (and incorrect) cmake install prefix argument by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1042\r\n* Use `size_t` in decl and def of `createExitWithID` by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1063\r\n* Keep CMake target rules if defined by @tom91136 in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1065\r\n* Fix build with ROCm Clang 5.5.0 by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1040\r\n* Optimize submission process for eager submission case by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1054\r\n* Add aliases for `marray` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1075\r\n* Use fixed width int types in SSCP builtin interface by @fxzjshm in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1076\r\n* Fix error when compiling with `-std=c++20` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1083\r\n* [DOC] fix the broken link to the wiki article in the README.md by @0dminnimda in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1080\r\n* Fix comment about (cuda|hip)StreamCreateWithPriority by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1086\r\n* Return device architecture in info::device::version by @al42and in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1084\r\n* Implement iterators for the accessor class by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1008\r\n* Let hipSYCL-rt be a non-transitive dependency. by @eirrgang in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1069\r\n* [SSCP][llvm-to-spirv] Use pown(double, i32) since IGC does not support pown(double, i64) by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1091\r\n* [L0] Take EUs into account when calculating compute units by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1106\r\n* Add C++ standard parallelism offloading support by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1088\r\n* Add OpenCL backend by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1109\r\n* Fix fill with offset by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1111\r\n* [OpenCL] Fix accessing build log by @fxzjshm in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1115\r\n* [stdpar] Don't use hipMemcpy and hipMemset due to performance issue with shared allocations by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1120\r\n* [SSCP] Strip module level inline assembly from device code by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1123\r\n* Use `FindCUDAToolkit` for cmake versions >= 3.17 by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1124\r\n* Pass CUDA libraries in FindCUDA.cmake as a list by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1127\r\n* [stdpar] Implement `{m,aligned_}alloc` and `free` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1114\r\n* [NFC] Add image of compiler stack to documentation by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1126\r\n* Allow for non-default-constructible iterators in `std::for_each_n` by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1132\r\n* [CI] Run self-hosted runners only for actions started from main repository by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1133\r\n* [Renaming] Migrate syclcc flags and content to new name; add acpp alias by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1137\r\n* Bump version to 23.10.0 by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1136\r\n* [Renaming] Add AdaptiveCpp cmake infrastructure, migrate tests to use new cmake integration by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1144\r\n* [Renaming][NFC] Migrate to new name in documentation and images by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1142\r\n* [renaming] Rename opensycl-hcf-tool and opensycl-info to acpp-hcf-tool and acpp-info by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1149\r\n* [renaming] libopensycl-clang.so -> libacpp-clang.so by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1153\r\n* [renaming] Use AdaptiveCpp in debug output instead of hipSYCL by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1152\r\n* [renaming] Support ACPP_* environment variables by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1151\r\n* update build instructions - easy by @jamesreinders in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1157\r\n* [NFC] Add note to describe potential perf pitfall due to OpenMP runtime mismatch by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1158\r\n* Fix compilation error with LLVM 18 by @tom91136 in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1159\r\n* [renaming] Remove obsolete file by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1160\r\n* Add workaround for clang CUDA header incompatibility by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1161\r\n* [HipLike] add header noinline workaround for gcc-13 by @tdavidcl in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1162\r\n* add parallel_for overloads with a number by @bashbaug in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1163\r\n* Add `get_backend` to Interop handle by @normallytangent in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1141\r\n* Fix HIPSYCL_RT_SANITIZE cmake option by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1171\r\n* Fix UB in test cases by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1173\r\n* [renaming] libopensycl-common -> libacpp-common, libhipSYCL-rt -> libacpp-rt by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1174\r\n* Fix clang-16 and newer include path by @karolherbst in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1177\r\n* Update the path to include directory in AdaptiveCpp's installation by @normallytangent in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1170\r\n* [SSCP][llvm-to-ptx] Strip debug information to avoid JIT failures when using -g by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1168\r\n* [SSCP] Handle circular references in globals by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1166\r\n* Redesign execution hints to avoid dynamic memory allocation and allow faster queries by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1178\r\n* buffer allocation: Avoid requesting alignments not supported by backends by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1184\r\n* [SSCP][llvm-to-spirv] Don't error if requested local memory is unused by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1185\r\n* [CI] Update nvc++ to 23.9 and resolve nvc++ CI issues by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1181\r\n* [renaming] Support ACPP_DEBUG_LEVEL in compiler and tools by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1186\r\n* [SSCP][llvm-to-spirv] Do not use cmake INSTALL_DIR to install llvm-spirv translator by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1172\r\n* [SSCP] Fix excessive global pruning introduced in #1166 by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1187\r\n* [OpenCL] Fix typo potentially causing USM pointer queries to fail by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1192\r\n* [SSCP][llvm-to-spirv] Also strip debug information for SPIR-V JIT by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1191\r\n* [OpenCL] Correctly initialize is_from_host_backend when querying USM pointer info by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1193\r\n* Introduce small_vector support by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1182\r\n* [CI][CBS] Enable LLVM 17 in CI by @fodinabor in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1195\r\n* Print more detailed version information; allow custom version suffix by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1167\r\n* [L0] Handle USM pointer queries in a more robust way if the pointer is unknown by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1197\r\n* Update `sycl::exception` class to SYCL2020 by @nilsfriess in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1066\r\n* [CI] Expand LIT infrastructure to SSCP and add some SSCP CI tests by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1196\r\n* Add instant submission mode by @illuhad in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1128\r\n\r\n## New Contributors\r\n* @RaulPPelaez made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/967\r\n* @Momellouky made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1017\r\n* @tdavidcl made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/965\r\n* @tom91136 made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1065\r\n* @0dminnimda made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1080\r\n* @eirrgang made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1069\r\n* @jamesreinders made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1157\r\n* @bashbaug made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1163\r\n* @karolherbst made their first contribution in https://github.com/AdaptiveCpp/AdaptiveCpp/pull/1177\r\n\r\n**Full Changelog**: https://github.com/AdaptiveCpp/AdaptiveCpp/compare/v0.9.4...v23.10.0-alpha", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v23.10.0-alpha", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v23.10.0-alpha", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v23.10.0-alpha", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/125786932", "release_id": 125786932, "date_created": "2023-10-18T22:31:26Z", "date_published": "2023-10-19T12:03:29Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/89940761", "tag": "v0.9.4", "name": "hipSYCL 0.9.4", "author": {"name": "illuhad", "type": "User"}, "description": "\r\n\r\n**This is a maintenance release, intended as a last stop before major additions. It therefore does not include major functionality already available on the develop branch such as the generic single-pass compiler.**\r\n\r\n## Build instruction addendum\r\n\r\nFor build instructions and issues that were discovered post-release (e.g. about compatibility with LLVM versions that were not yet released at the time), please see here:\r\nhttps://github.com/AdaptiveCpp/AdaptiveCpp/wiki/Build-instructions-for-old-versions#hipsycl-094\r\n\r\n## What's Changed\r\n* Add minimal install script by @illuhad in https://github.com/illuhad/hipSYCL/pull/819\r\n* Fix handling of HCF object id when both CUDA and HIP are in explicit multipass by @illuhad in https://github.com/illuhad/hipSYCL/pull/831\r\n* Fix device::max_work_item_sizes by @nmnobre in https://github.com/illuhad/hipSYCL/pull/832\r\n* Add HIPSYCL_SYCLCC_EXTRA_COMPILE_OPTIONS by @al42and in https://github.com/illuhad/hipSYCL/pull/824\r\n* [CBS] Cope with a minor LLVM API change. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/843\r\n* [CI] Enable LLVM 15. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/844\r\n* replace activemask with ballot function by @DieGoldeneEnte in https://github.com/illuhad/hipSYCL/pull/838\r\n* Make embedded_pointer store pointer which than convert to unique_id rather than the other way round by @illuhad in https://github.com/illuhad/hipSYCL/pull/821\r\n* Update comment on nvc++ workaround in mem_fence() by @nmnobre in https://github.com/illuhad/hipSYCL/pull/849\r\n* Use -isystem instead of -I for hipSYCL headers to avoid warnings with high warning levels by @illuhad in https://github.com/illuhad/hipSYCL/pull/859\r\n* Add implicit conversion for item<1> to size_t by @illuhad in https://github.com/illuhad/hipSYCL/pull/847\r\n* Remove comparing `my_id` since it does not exist in class item by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/868\r\n* Remove unnecessary/wrong consts by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/876\r\n* Fix hipSYCL clang plugin path on MacOS by @illuhad in https://github.com/illuhad/hipSYCL/pull/883\r\n* Add vec deduction guides and fix swizzles when directly accessed using .elem() by @illuhad in https://github.com/illuhad/hipSYCL/pull/866\r\n* Ensure that `device{} == device{default_selector{}}` by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/888\r\n* [CBS] Cleanup globals if unused loads still around by @fodinabor in https://github.com/illuhad/hipSYCL/pull/887\r\n* WIP: Fix MacOS build CI by @normallytangent in https://github.com/illuhad/hipSYCL/pull/882\r\n* Rename `global_mem_cache_type::write_only` to `read_write` by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/875\r\n* Fix LLVM 16 compat. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/893\r\n* Add clang include path from lib64. (Fix building on opensuse tumbleweed) by @marknefedov in https://github.com/illuhad/hipSYCL/pull/898\r\n\r\n## New Contributors\r\n* @marknefedov made their first contribution in https://github.com/illuhad/hipSYCL/pull/898\r\n\r\n**Full Changelog**: https://github.com/illuhad/hipSYCL/compare/v0.9.3...v0.9.4", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.9.4", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.9.4", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.9.4", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/89940761", "release_id": 89940761, "date_created": "2023-01-23T16:48:30Z", "date_published": "2023-01-23T16:58:19Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/75925433", "tag": "v0.9.3", "name": "hipSYCL 0.9.3", "author": {"name": "illuhad", "type": "User"}, "description": "## Highlights\r\n\r\n* Improved compatibility with new clang versions and ROCm clang\r\n* New extensions, e.g.\r\n  * coarse grained events. These are zero-construction-cost events at the expense of lower synchronization performance, and hence a good match if the returned event of an operation is not expected to be used\r\n  * queue priorities for in-order queues on certain backends\r\n* Added `hip.explicit-multipass` compilation flow\r\n* Multiple optimizations that can potentially reduce runtime overheads substantially\r\n  * Use event pools in CUDA/HIP backends\r\n  * Use asynchronous garbage collector thread to clean up old DAG nodes to remove garbage collection from the kernel submission path\r\n  * Use `std::weak_ptr` instead of `shared_ptr` to express dependencies in the DAG; making old DAG nodes and their associated events eligible earlier for reuse by the event pool.\r\n* In-order queues map 1:1 to dedicated CUDA or HIP streams for more explicit scheduling control\r\n* Unified kernel cache and data format for all explicit multipass compilation flow (hipSYCL container format, HCF)\r\n* Manage hipSYCL runtime lifetime by refcounting all SYCL objects created by the user instead of just having a global object; this can resolve errors when terminating the program on some backends.\r\n* Simplify deployment when no `std::filesystem` is available\r\n* New tool: `hipsycl-hcf-tool` to inspect and edit HCF files\r\n* New tool: `hipsycl-info` to print information about detected devices.\r\n\r\n## What's Changed (details)\r\n* Fix SPIR-V isnan() builtin by @illuhad in https://github.com/illuhad/hipSYCL/pull/710\r\n* Don't spill OpenMP pragmas and add .sycl as file ending by @illuhad in https://github.com/illuhad/hipSYCL/pull/711\r\n* Update installation scripts by @sbalint98 in https://github.com/illuhad/hipSYCL/pull/677\r\n* Fix typo in macro name causing harmless warnings by @al42and in https://github.com/illuhad/hipSYCL/pull/715\r\n* Check all dyn casts in analyzeModule. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/717\r\n* Align name mangling in clang 13 host pass with upstream clang and restrict uses of createDeviceMangleContext() by @illuhad in https://github.com/illuhad/hipSYCL/pull/720\r\n* Add missing include directive for unordered_map by @normallytangent in https://github.com/illuhad/hipSYCL/pull/735\r\n* Make random number generators for embedded_pointer unique id thread_local by @illuhad in https://github.com/illuhad/hipSYCL/pull/738\r\n* Fix multi-threaded task processing by @illuhad in https://github.com/illuhad/hipSYCL/pull/739\r\n* dag_node: Only use backend wait() functionality if we are not yet complete by @illuhad in https://github.com/illuhad/hipSYCL/pull/742\r\n* Describe boost 1.78 build system bug in documentation by @illuhad in https://github.com/illuhad/hipSYCL/pull/744\r\n* Add released LLVM 14 to Linux CIs. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/747\r\n* Add global kernel cache and HCF infrastructure by @illuhad in https://github.com/illuhad/hipSYCL/pull/736\r\n* Fix fiinding boost library path for boost with cmake intgeration  by @sbalint98 in https://github.com/illuhad/hipSYCL/pull/748\r\n* Use reference-counting of user SYCL objects to manage runtime lifetime by @illuhad in https://github.com/illuhad/hipSYCL/pull/749\r\n* Restrict queries of event state by @illuhad in https://github.com/illuhad/hipSYCL/pull/750\r\n* Fix signature of __hipsycl_atomic_store for double and float by @al42and in https://github.com/illuhad/hipSYCL/pull/751\r\n* [CUDA][HIP] Add event pool by @illuhad in https://github.com/illuhad/hipSYCL/pull/757\r\n* Add coarse grained events extension by @illuhad in https://github.com/illuhad/hipSYCL/pull/754\r\n* Make max cached nodes configurable by @illuhad in https://github.com/illuhad/hipSYCL/pull/759\r\n* [cbs] Fix compatibility issues with upstream Clang/LLVM by @aaronmondal in https://github.com/illuhad/hipSYCL/pull/763\r\n* [CBS] Fix runtime issues with opaque pointers by @fodinabor in https://github.com/illuhad/hipSYCL/pull/765\r\n* [Plugin] Resolve version macros in HIPSYCL_STRINGIFY by @aaronmondal in https://github.com/illuhad/hipSYCL/pull/773\r\n* Add missing sycl::nd_range::get_group_range function by @al42and in https://github.com/illuhad/hipSYCL/pull/775\r\n* Add HIPSYCL_RT_SANITIZE cmake option by @illuhad in https://github.com/illuhad/hipSYCL/pull/779\r\n* Update ROCm installation documentation by @illuhad in https://github.com/illuhad/hipSYCL/pull/780\r\n* Remove unnecessary linking against boost for the clang plugin by @illuhad in https://github.com/illuhad/hipSYCL/pull/781\r\n* Use weak_ptr in node requirements list by @illuhad in https://github.com/illuhad/hipSYCL/pull/771\r\n* [CI] fix compilation on MSVC 2017 by @fxzjshm in https://github.com/illuhad/hipSYCL/pull/784\r\n* dag_submitted_ops: Manage node lifetime by asynchronously waiting instead of event queries by @illuhad in https://github.com/illuhad/hipSYCL/pull/761\r\n* Optimize queue::wait() by waiting on nodes in reverse submission order by @illuhad in https://github.com/illuhad/hipSYCL/pull/787\r\n* Remove OpenMP dependency for sequential backend by @illuhad in https://github.com/illuhad/hipSYCL/pull/786\r\n* Optimize inorder queue::wait() by @illuhad in https://github.com/illuhad/hipSYCL/pull/788\r\n* Add support for HIP explicit multipass by @illuhad in https://github.com/illuhad/hipSYCL/pull/790\r\n* Add hipsycl-info tool by @illuhad in https://github.com/illuhad/hipSYCL/pull/791\r\n* Fix ThreadSanitizer complaint about worker_thread::_continue by @al42and in https://github.com/illuhad/hipSYCL/pull/794\r\n* Avoid printing unprintable from memset_operation::dump by @al42and in https://github.com/illuhad/hipSYCL/pull/795\r\n* Fix linking errors with libstdc++ < 9 by @al42and in https://github.com/illuhad/hipSYCL/pull/667\r\n* Use device managers in allocators instead of setting device directly by @illuhad in https://github.com/illuhad/hipSYCL/pull/796\r\n* Work around nvc++ bug by not having empty if target branches in mem_fence() by @illuhad in https://github.com/illuhad/hipSYCL/pull/798\r\n* Manually check version of clang if ROCm is used. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/800\r\n* Implement sincos and sinh math builtins by @nmnobre in https://github.com/illuhad/hipSYCL/pull/802\r\n* Add dedicated backend queues for inorder queues and priority queue support by @illuhad in https://github.com/illuhad/hipSYCL/pull/770\r\n* Add HIPSYCL_EXT_QUEUE_PRIORITY flag by @al42and in https://github.com/illuhad/hipSYCL/pull/804\r\n* Fix CMake error with ROCm 4.5 Clang by @al42and in https://github.com/illuhad/hipSYCL/pull/806\r\n* Add option to compile tests with reduced local mem usage by @illuhad in https://github.com/illuhad/hipSYCL/pull/805\r\n* omp.library-only: Fix incorrect addition of master group offset to group id by @illuhad in https://github.com/illuhad/hipSYCL/pull/814\r\n* Bump version to 0.9.3 by @illuhad in https://github.com/illuhad/hipSYCL/pull/803\r\n\r\n\r\n## New Contributors\r\n* @normallytangent made their first contribution in https://github.com/illuhad/hipSYCL/pull/735\r\n* @aaronmondal made their first contribution in https://github.com/illuhad/hipSYCL/pull/763\r\n* @nmnobre made their first contribution in https://github.com/illuhad/hipSYCL/pull/802\r\n\r\nThank you to our first-time contributors!\r\n\r\n\r\n**Full Changelog**: https://github.com/illuhad/hipSYCL/compare/v0.9.2...v0.9.3", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.9.3", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.9.3", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.9.3", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/75925433", "release_id": 75925433, "date_created": "2022-08-31T16:32:41Z", "date_published": "2022-08-31T16:34:31Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/59532725", "tag": "v0.9.2", "name": "hipSYCL 0.9.2", "author": {"name": "illuhad", "type": "User"}, "description": "# Changes  compared to the previous release 0.9.1 (selection)\r\n\r\nThe following is an incomplete list of changes and improvements:\r\n\r\n## Highlights\r\n\r\n* Initial support for **operating as a pure CUDA library for NVIDIA's proprietary nvc++ compiler**, without any additional hipSYCL compiler magic. In this flow, LLVM is not required and new NVIDIA hardware can be targeted as soon as NVIDIA adds support in nvc++.\r\n* Initial support for **dedicated compiler support in the CPU backend**. These new compilation passes can greatly improve performance of nd_range parallel for kernels on CPU. **This allows executing SYCL code efficiently on any CPU supported by LLVM**.\r\n* **Scoped parallelism API v2** for a more performance portable programming model\r\n* Reimplement explicit multipass support for clang >= 13. This allows targeting multiple backends simultaneously, and was previously only supported on clang 11. Kernel names in the binary are now always demangleable as `__hipsycl_kernel<KernelNameT>` or `__hipsycl_kernel<KernelBodyT>`.\r\n\r\n## SYCL support\r\n\r\n* Support for new SYCL 2020 features such as `atomic_ref`, device selector API, device aspect API and others\r\n* Support for SYCL 2020 final group algorithm interface\r\n* Add support for the profiling API\r\n* ... more\r\n\r\n## Extensions\r\n\r\n* Add initial support for multi-device queue hipSYCL extension to automatically distribute work across multiple devices\r\n* Add initial support for `queue::get_wait_list()` hipSYCL extension to allow barrier-like semantics at the queue level\r\n* Add `accessor_variant` extension which allows accessors to automatically optimize the internal data layout of the accessor object depending on how they were constructed. This can save registers on device without any changes needed by the user.\r\n* Add `handler::update_device()` extension in analogy to already existing `update_host()`. This can be e.g. used to prefetch data.\r\n* Complete buffer-USM interoperability API\r\n* Add support for explicit buffer policy extension and asynchronous buffers\r\n\r\nSee the documentation on [extensions](https://github.com/illuhad/hipSYCL/blob/develop/doc/extensions.md) for more details.\r\n\r\n## Optimizations\r\n\r\n* Automatic work distribution across multiple streams\r\n* Fix massive performance bug caused by a bug in the kernel cache in the Level Zero backend\r\n* Optimize CUDA backend to perform aggressive CUDA module caching in an explicit multipass scenario. This can greatly improve performance of the `cuda.explicit-multipass` compilation flow when multiple translation units are involved.\r\n* Several performance fixes and improvements in the hipSYCL runtime. Especially when spawning many tasks, performance can now be significantly better.\r\n* ... more\r\n\r\n## Bug fixes and other improvements\r\n\r\nYes, a lot of them :-)\r\n", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.9.2", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.9.2", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.9.2", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/59532725", "release_id": 59532725, "date_created": "2022-02-14T17:07:50Z", "date_published": "2022-02-14T17:16:43Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/40646537", "tag": "v0.9.1", "name": "hipSYCL 0.9.1", "author": {"name": "illuhad", "type": "User"}, "description": "# hipSYCL 0.9.1\r\n\r\n*-- This release is dedicated to the memory of Oliver M. Some things just end too soon.*\r\n\r\n## New major features\r\n\r\n* **Add new \"explicit multipass\" compilation model**, allowing to simultaneously target all of hipSYCL's backends. **This means hipSYCL can now compile to a binary that runs can run on devices from multiple vendors**. Details on the compilation flow can be found here: https://github.com/illuhad/hipSYCL/blob/develop/doc/compilation.md\r\n* **Introduce plugin architecture for backends of the hipSYCL runtime**. This means hipSYCL now looks for backend plugins at runtime, allowing to extend an already existing hipSYCL installation with support for additional hardware without changing the already installed components.\r\n* **Initial, experimental support for Intel GPUs using Level Zero and SPIR-V**\r\n* **Introducing initial support for large portions of oneDPL** using our fork at https://github.com/hipSYCL/oneDPL\r\n* hipSYCL is now also tested on Windows in CI, although Windows support is still experimental.\r\n\r\n## New features and extensions\r\n* **Command group properties** that can influence how kernels or other operations are scheduled or executed:\r\n    * `hipSYCL_retarget` command group property. Execute an operation submitted to a queue on an arbitrary device instead of the one the queue is bound to.\r\n    * `hipSYCL_prefer_group_size<Dim>` command group property. Provides a recommendation to hipSYCL which group size to choose for basic parallel for kernels.\r\n    * `hipSYCL_prefer_execution_lane` command group property. Provides a hint to the runtime on which backend queue (e.g. CUDA stream) an operation should be executed. This can be used to optimize kernel concurrency or overlap of data transfers and compute in case the hipSYCL scheduler does not already automatically submit an optimal configuration.\r\n* **Comprehensive interoperability framework between buffers and USM pointers**. This includes extracting USM pointers from existing `buffer` objects, turning any `buffer` into a collection of USM pointers, as well as constructing `buffer` objects on top of existing USM pointers.\r\n* The `hipSYCL_page_size` buffer property can be used to enable data state tracking inside a buffer at a granularity below the buffer size. This can be used to **allow multiple kernels to concurrently write to the same buffer** as long as they access different hipSYCL data management pages. Unlike subbuffers, this also works with **multi-dimensional strided memory accesses**.\r\n* Synchronous `sycl::mem_advise()` as free function\r\n* `handler::prefetch_host()` and `queue::prefetch_host()` for a simpler mechanism of prefetching USM allocations to host memory.\r\n* **Explicit buffer policies to make programmer intent clearer** as well as **asynchronous buffer types that do not block in the destructor**, which can improve performance. For example, `auto v = sycl::make_async_view(ptr, range)` constructs a buffer that operates directly on the input pointer and does not block in the destructor.\r\n* `HIPSYCL_VISIBLITY_MASK` environment variable can be used to select which backends should be loaded.\r\n\r\nSee https://github.com/illuhad/hipSYCL/blob/develop/doc/extensions.md for a list of all hipSYCL extensions with more details.\r\n\r\n## Optimizations and improvements\r\n* Hand-tuned **optimizations for SYCL 2020 group algorithms**\r\n* **Automatic distribution of kernels across multiple CUDA/HIP streams**\r\n* Improved support for newer ROCm versions\r\n* SYCL 2020 accessor deduction guides and `host_accessor`\r\n* Improve handling of Multi-GPU setups\r\n* **Significant performance improvements for** `queue::wait()`\r\n* Early DAG optimizations to improve handling of complex and large dependency graphs\r\n* Optimizations to **elide unnecessary synchronization** between DAG nodes\r\n\r\n## Bug fixes and other improvements\r\n\r\nYes, a lot of them!", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.9.1", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.9.1", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.9.1", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/40646537", "release_id": 40646537, "date_created": "2021-03-29T16:34:02Z", "date_published": "2021-03-29T16:38:59Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/35100346", "tag": "v0.9.0", "name": "hipSYCL 0.9.0", "author": {"name": "illuhad", "type": "User"}, "description": "# hipSYCL 0.9.0\r\n\r\nhipSYCL 0.9 is packed with tons of new features compared to the older 0.8 series:\r\n\r\n# Support for key SYCL 2020 features\r\n\r\nhipSYCL 0.9.0 introduces support for several key SYCL 2020 features, including:\r\n* **Unified shared memory** provides a pointer-based memory model as an alternative to the traditional buffer-accessor model\r\n* SYCL 2020 **generalized backend model and backend interoperability** provides generic mechanisms for interoperability between the underlying backend objects and SYCL\r\n* **Queue shortcuts** for kernel invocation and USM memory management functions\r\n* **Inorder queues** to submit kernels in order when a task graph is not required\r\n* **Unnamed kernal lambdas** (requires building hipSYCL against clang >= 10)\r\n* **Subgroups**\r\n* **Group algorithms** for parallel primitives at work group and subgroup level (Note that the interface may change slightly with the release of SYCL 2020 final, optimization is ongoing)\r\n* **Reductions** provide a simple way to carry out arbitrary amounts of reduction operations across all work items of a kernel using either predefined or user-provided reduction operators (Note that the interface may change slightly with the release of SYCL 2020 final, optimization is ongoing). Currently only scalar reductions are supported. Multiple simultaneous reductions *are* supported. In addition to the requirements of the SYCL specification, we also support reductions for the hierarchical and scoped parallelism models.\r\n* ... and more! See here for more information on the SYCL 2020 coverage of current hipSYCL: https://github.com/hipSYCL/featuresupport\r\n\r\n# Unique hipSYCL extensions\r\n\r\nThere are two new extensions in hipSYCL 0.9.0:\r\n* **Enqueuing custom backend operations** for highly efficient backend interoperability: https://github.com/illuhad/hipSYCL/blob/develop/doc/enqueue-custom-operation.md\r\n* **Scoped parallellism** is a novel kernel execution model designed for performance portability between host and device backends: https://github.com/illuhad/hipSYCL/blob/develop/doc/scoped-parallelism.md\r\n\r\n# New runtime library\r\n\r\nhipSYCL 0.9.0 is the first release containing the entirely rewritten, brand new runtime library, which includes features such as:\r\n\r\n  * **Single library for all backends** (`libhipSYCL-rt`) instead of libraries for each backend (`libhipSYCL_cpu`, `libhipSYCL_cuda` etc)\r\n  * **Strict seperation between backend specific code and generic code**, clear, simple interface to add new backends, making it easy to add additional backends in the future\r\n  * **Multiple runtime backends can now be active at the same time and interact**\r\n  * SYCL interface is now header-only; bootstrap mode in `syclcc` is no longer required and has been removed. **When building hipSYCL, only the runtime needs to be compiled which can be done with any regular C++ compiler.** This should simplify the build process greatly.\r\n  * Architecture supports **arbitrary execution models in different backends** - queue/stream based, task graphs etc.\r\n  * **CUDA and CPU backends do not depend on HIP API anymore**. The CUDA backend now goes directly to CUDA without going through HIP, and the CPU backend goes directly to OpenMP without going through hipCPU. hipCPU and HIP submodules are no longer required and have been removed.\r\n  * **Strict separation between SYCL interface and runtime**, making it easy to expose new features (e.g. SYCL 2020) in the SYCL interface by leveraging the SYCL runtime interfaces underneath.\r\n  * For each operation, SYCL interface can pass additional information to runtime/scheduler using hints framework. **Device on which an operation is executed is just another hint for the runtime.**\r\n  * **Support for lazy DAG execution** (Note: Only partially activated by default)\r\n  * **Almost entirely callback-free execution model in CUDA/ROCm backends for potentially higher task throughput**\r\n  * **New memory management system and improved multi-GPU support**\r\n     - manages arbitrary allocations on multiple devices\r\n     - manages memory potentially below buffer granularity, using 3D page table to track invalid memory regions (not yet fully exposed)\r\n  * Backend queues (e.g. CUDA streams) are maintained by the backend in a pool, the scheduler then distributes operations across the queues. **No matter how many `sycl::queues` exist, compute/memory-overlap always works equally well.** This means a `sycl::queue` is now nothing more than an interface to the runtime.\r\n  * **Vastly improved error handling**. Proper implementation of async errors/error handlers. Task execution will be cancelled when an error is detected.\r\n  * **ROCm backend: Add support for 3D data transfers**\r\n\r\n# `syclcc` and compilation improvements\r\n* new `--hipsycl-targets` flag that allows to compile for multiple targets and backends, e.g. `syclcc --hipsycl-targets=\"omp;hip:gfx906,gfx900\"` compiles for the OpenMP backend as well as for Vega 10 and Vega 20. Note that simultaneous compilation for both NVIDIA and AMD GPUs is not supported due to clang limitations.\r\n* The compiler arguments and linker flags passed to backend compilers are now all exposed in cmake (and `syclcc.json`), giving the user more control to adapt the compilation flow to individual requirements. This can be helpful for uncommon setup scenarios where different flags may be required.\r\n\r\n# Performance improvements\r\n\r\n* New execution model for `nd_range` parallel for on CPU, bringing several orders of magnitudes of performance. Note that `nd_range` parallel for is inherently difficult to implement in library-only CPU backends, and basic `parallel for` or our scoped parallelism extension should be preferred if possible.\r\n\r\n# Fixes and other improvements\r\n\r\nYes, a lot of them :-)\r\n\r\n\r\n", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.9.0", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.9.0", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.9.0", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/35100346", "release_id": 35100346, "date_created": "2020-12-10T13:51:51Z", "date_published": "2020-12-10T13:55:00Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/20220027", "tag": "v0.8.0", "name": "hipSYCL 0.8.0", "author": {"name": "illuhad", "type": "User"}, "description": "**Note: hipSYCL 0.8.0 is deprecated**, *users are encouraged to use our [package repositories](https://github.com/illuhad/hipSYCL/blob/master/install/scripts/README.md#installing-from-repositories) instead*\r\n\r\nThis is the release of hipSYCL 0.8.0. We provide the following packages:\r\n\r\n* hipSYCL-base provides the basic LLVM compiler stack that is needed in any case\r\n* hipSYCL-rocm provides a compatible ROCm stack that additionally allows hipSYCL to target AMD GPUs\r\n* hipSYCL provides the actual hipSYCL libraries, tools and headers\r\n\r\nWhile we cannot provide matching CUDA packages for NVIDIA support due to legal reasons, scripts for installing a matching CUDA distribution as well as scripts to generate CUDA packages are provided. You will find further information in the readme here on github.\r\n\r\nAt the moment, Arch Linux, CentOS 7 and Ubuntu 18.04 packages are provided.\r\n", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.8.0", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.8.0", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.8.0", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/20220027", "release_id": 20220027, "date_created": "2019-09-24T16:08:22Z", "date_published": "2019-09-24T17:44:57Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/20124298", "tag": "v0.8.0-rc1", "name": "hipSYCL 0.8.0 Release Candidate 1", "author": {"name": "illuhad", "type": "User"}, "description": "This is a prerelease of hipSYCL 0.8.0. In particular, it serves to test new packages of the entire hipSYCL stack. We provide the following packages:\r\n* `hipSYCL-base` provides the basic LLVM compiler stack that is needed in any case\r\n* `hipSYCL-rocm` provides a compatible ROCm stack that additionally allows hipSYCL to target AMD GPUs\r\n* `hipSYCL` provides the actual hipSYCL libraries, tools and headers\r\n\r\nWhile we cannot provide matching CUDA packages due to legal reasons, CUDA installation scripts will be provided for the actual hipSYCL 0.8.0 release.\r\n\r\nAt the moment, Arch Linux and Ubuntu 18.04 packages are provided. ", "tarball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/tarball/v0.8.0-rc1", "zipball_url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/zipball/v0.8.0-rc1", "html_url": "https://github.com/AdaptiveCpp/AdaptiveCpp/releases/tag/v0.8.0-rc1", "url": "https://api.github.com/repos/AdaptiveCpp/AdaptiveCpp/releases/20124298", "release_id": 20124298, "date_created": "2019-09-19T14:54:58Z", "date_published": "2019-09-19T23:40:00Z"}, "confidence": 1, "technique": "GitHub_API"}], "readme_url": [{"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "contributing_guidelines": [{"result": {"value": "*Thank you for your interest in contributing to AdaptiveCpp! Your PR will be highly appreciated* :-) \n\nWhen in doubt about how to implement something or how to integrate with the overall project strategy, please just open an issue for discussion.\n\n# Important branches in AdaptiveCpp\n\nPlease take note of the branch structure of the project. The following are important branches:\n\n* `stable` - contains latest AdaptiveCpp with additional testing. `stable` should always contain a version of AdaptiveCpp that we are confident is stable.\n* `develop` - contains latest development version.\n* `sycl/VERSION` - contains AdaptiveCpp code that targets a specific SYCL version.\n   - `sycl/1.2.1` - contains latest AdaptiveCpp targeting SYCL 1.2.1. This branch is now mainly in maintenance mode. If you want to specifically improve AdaptiveCpp SYCL 1.2.1 support, please use this branch.\n   - `sycl/2020` - contains latest AdaptiveCpp work targeting SYCL 2020, and any work that is not specific to earlier SYCL versions.\n\nWe periodically perform the following merges:\n* `develop` -> `sycl/<latest-version>` -> `stable`\n\n\nPlease follow the following guidelines:\n* **File your PR against the `develop` branch, unless you are specifically targeting an earlier SYCL version.**\n* **If you are targeting an earlier SYCL version, target the appropriate `sycl/<version>` branch**\n   \n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/CONTRIBUTING.md"}, {"result": {"value": "We encourage contributions and are looking forward to your pull request! Please have a look at [CONTRIBUTING.md](CONTRIBUTING.md). If you need any guidance, please just open an issue and we will get back to you shortly.\n\nIf you are a student at Heidelberg University and wish to work on AdaptiveCpp, please get in touch with us. There are various options possible and we are happy to include you in the project :-)\n", "type": "Text_excerpt", "original_header": "Contributing to AdaptiveCpp", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "has_script_file": [{"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_singularity_containers.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/test-packages.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_repos.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/test-installation.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/record_env_vars.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/publish_test_container.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/update_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_pkgs.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_ubuntu_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_centos_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_arch_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/common/init.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-hipsycl.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-cuda.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-llvm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/hipsycl-minimal-install.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/rebuild-images.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-base-spack.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-rocm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-ubuntu-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-8-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-ubuntu-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-archlinux-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-7-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-archlinux-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/common/init.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/cuda.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/llvm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/rocm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/boost.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/hipsycl.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/centos-7.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/ubuntu-18.04.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/ubuntu-20.04.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/archlinux-rolling.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/cleanup_syclcchelp.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "installation": [{"result": {"value": "# AdaptiveCpp installation instructions for SPIR-V/Level Zero\n\nPlease install the Level Zero loader and a Level Zero driver such as the Intel [compute runtime](https://github.com/intel/compute-runtime) for Intel GPUs.\n\nThe Level Zero backend can be enabled using `cmake -DWITH_LEVEL_ZERO_BACKEND=ON` when building AdaptiveCpp.\n\n\n## For the legacy SPIR-V compilation flow (`--acpp-targets=spirv`)\n**Please ignore the following if you actually want to use the more modern generic single-pass compiler (`--acpp-targets=generic`), which is recommended.**\n\nPlease build AdaptiveCpp against a clang/LLVM that has Intel's patches to generate SPIR-V, following the [LLVM installation instructions](install-llvm.md). Once all required patches are upstreamed this will work with regular clang distributions; until then AdaptiveCpp needs to be built against DPC++/Intel's LLVM [fork](https://github.com/intel/llvm).\nUnfortunately, the binary distribution of DPC++ do not contain development headers, so the clang plugin required by the CUDA and ROCm backends cannot be compiled, but the open source fork should be able to also target CUDA and ROCm.\n\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-spirv.md"}, {"result": {"value": "# AdaptiveCpp installation instructions for SPIR-V/OpenCL\n\nYou will need an OpenCL implementation, and the OpenCL icd loader. The OpenCL library can be specified using `cmake -DOpenCL_LIBRARY=/path/to/libOpenCL.so`.\n\nThe OpenCL backend can be enabled using `cmake -DWITH_OPENCL_BACKEND=ON` when building AdaptiveCpp.\nIn order to run code successfully on an OpenCL device, it must support SPIR-V ingestion and the Intel USM (unified shared memory) extension. In a degraded mode, devices supporting OpenCL fine-grained system SVM (shared virtual memory) may work as well.\n\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-ocl.md"}, {"result": {"value": "# LLVM dependency installation instructions\n\nCertain backends/compilation flows require LLVM. This is because AdaptiveCpp needs to build a clang plugin which is then loaded into clang to provide the required compiler support for SYCL.\n\nGenerally, we recommend the latest officially released clang/LLVM versions, but older versions might also work depending on the compilation flow (see the table from the main installation instructions).\n\nUsually, the clang/LLVM versions provided in Linux distribution repositories are sufficient, if they are recent enough. \n*In this case, AdaptiveCpp might automatically detect and configure your LLVM installation without additional cmake arguments required.* **We therefore recommend to make your life easy: Check your distribution's LLVM version against the AdaptiveCpp requirements and if they match, use it**.\n\nIf you are using Ubuntu or Debian, we can also recommend the package repositories at `http://apt.llvm.org` if you wish to obtain a newer LLVM.\n\nInstall\n* clang (including development headers)\n* LLVM (including development headers)\n* libomp (including development headers)\n* lld (only for the ROCm backend)\n\nFor example, the required steps to install clang 16 on an Ubuntu system are:\n```\nwget https://apt.llvm.org/llvm.sh #Convenience script that sets up the repositories\nchmod +x llvm.sh\n./llvm.sh 16 #Set up repositories for clang 16\napt install -y libclang-16-dev clang-tools-16 libomp-16-dev llvm-16-dev lld-16\n```\n\n#### Only if you wish to compile LLVM from source (not recommended)\n\nIt is generally not necessary to compile LLVM by yourself. However, if you wish to do this, during LLVM cmake make sure to:\n\n- Disable assertions as AdaptiveCpp can potentially trigger some (false positive) debug assertions in some LLVM versions: `-DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=OFF -DLLVM_ENABLE_DUMP=OFF` \n- Generate `libLLVM.so`: `-DLLVM_BUILD_LLVM_DYLIB=ON` (only required if the SSCP compilation flow is enabled when building AdaptiveCpp, which is true by default for supported versions of LLVM)\n- Enable the correct backends for your hardware: `nvptx` for NVIDIA GPUs and `amdgpu` for AMD GPUs.\n\n## Pointing AdaptiveCpp to the right LLVM\n\nWhen invoking cmake, the AdaptiveCpp build infrastructure will attempt to find LLVM automatically (see below for how to invoke cmake).\n\nIf AdaptiveCpp does not automatically configure the build for the desired clang/LLVM installation, the following cmake variables can be used to point AdaptiveCpp to the right one:\n* `-DLLVM_DIR=/path/to/llvm/cmake` must be pointed to your LLVM installation, specifically, the **subdirectory containing the LLVM cmake files**. Note that different LLVM installations may have the LLVM cmake files in different subdirectories that don't necessarily end with `cmake` (e.g. it might also be `/path/to/llvm/lib/cmake/llvm`). Alternatively, you can try `-DLLVM_ROOT` which might be more forgiving.\n\nVerify from the cmake that the selected `clang++` and include headers match the LLVM that you have requested. Example output:\n```\n...\n-- Building AdaptiveCpp against LLVM configured from /usr/lib/llvm-16/cmake/\n-- Selecting clang: /usr/bin/clang++-16\n-- Using clang include directory: /usr/include/clang/16.0.1/include/..\n...\n```\n\nIf AdaptiveCpp does not select the right clang++ or include directories, use the following variables to set them manually:\n\n\n* `-DCLANG_EXECUTABLE_PATH=/path/to/clang++` must be pointed to the `clang++` executable from this LLVM installation.\n* `-DCLANG_INCLUDE_PATH=/path/to/clang-includes` must be pointed to the clang internal header directory. Typically, this is something like `$LLVM_INSTALL_PREFIX/include/clang/<llvm-version>/include`. Newer ROCm versions will require the parent directory instead, i.e. `$LLVM_INSTALL_PREFIX/include/clang/<llvm-version>`. This is only important for the ROCm backend.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-llvm.md"}, {"result": {"value": "# AdaptiveCpp installation instructions for CUDA\n\n## If using clang\n\nPlease install CUDA 10.0 or later.\n\nclang usually produces CUDA programs with very competitive performance compared to nvcc or nvc++. For more information on compiling CUDA with clang, please read [the LLVM documentation on CUDA support](http://llvm.org/docs/CompileCudaWithLLVM.html). **Note that the requirements on the CUDA installation described there.**\n\nIf you use a very recent CUDA version, you might get a warning when compiling with AdaptiveCpp that clang does not support your CUDA version and treats like an older version. This warning can usually safely be ignored.\n\nCMake variables:\n* `-DCUDA_TOOLKIT_ROOT_DIR=/path/to/cuda` to point AdaptiveCpp to the CUDA root installation directory (e.g. `/usr/local/cuda`), if cmake doesn't find the right CUDA installation.\n* `-DWITH_CUDA_BACKEND=ON` if AdaptiveCpp does not automatically enable the CUDA backend \n\n## If using nvc++\n\nPlease install the latest release of the NVIDIA HPC SDK and make sure to point AdaptiveCpp to nvc++ (see below).\nPlease install CUDA 10.0 or later. You can also rely on the CUDA bundled with the NVIDIA HPC SDK\n\nCMake variables:\n* `-DNVCXX_COMPILER=/path/to/nvc++`\n* You can use the CUDA bundled with nvc++. Make sure to point AdaptiveCpp to the right CUDA installation using `-DCUDA_TOOLKIT_ROOT_DIR=/path/to/cuda`. \n* `-DWITH_CUDA_BACKEND=ON` if AdaptiveCpp does not automatically enable the CUDA backend\n* `-DWITH_CUDA_NVCXX_ONLY=ON` enable if you want to use the CUDA backend exclusively with nvc++ and not clang. This will allow you to use nvc++ without having to install LLVM.", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-cuda.md"}, {"result": {"value": "\n# Building and installing AdaptiveCpp\n\n## Manual installation (Linux)\n\n### Software dependencies\nIn order to successfully build and install AdaptiveCpp, the following dependencies must be installed for all backends:\n\n* python 3 (for the `acpp` compiler driver)\n* `cmake`\n* the Boost C++ libraries (in particular `boost.fiber`, `boost.context` and for the unit tests `boost.test`)\n  * it may be helpful to set the `BOOST_ROOT` `cmake` variable to the path to the root directory of Boost you wish to use if `cmake` does not find it automatically\n  * **Note for boost 1.78 users:** There seems to be a bug in the build system for boost 1.78, causing the compiled fiber and context libraries not to be copied to the installation directory. You will have to copy these libraries manually to the installation directory. In binary packages from some distribution repositories this issue is fixed. You might be only affected when building boost manually from source.\n\nIn addition, the various supported [compilation flows](compilation.md) and programming models have additional requirements:\n\n#### Compilation flows\n\n| Compilation flow | Target hardware | Short description | Requirements |\n|------------------|-------------------|-------------------|-------------------|\n| `omp.library-only` | Any CPU | OpenMP CPU backend | Any OpenMP compiler |\n| `omp.accelerated` | Any CPU supported by LLVM | OpenMP CPU backend (compiler-accelerated)| LLVM >= 11 |\n| `cuda.integrated-multipass` | NVIDIA GPUs | CUDA backend (clang)| CUDA >= 10, LLVM >= 10 |\n| `cuda.explicit-multipass` | NVIDIA GPUs | CUDA backend (clang, can be targeted simultaneously with other backends) | CUDA >= 10, LLVM 11 or 13+ |\n| `cuda-nvcxx` | NVIDIA GPUs | CUDA backend (nvc++) | Latest NVIDIA HPC SDK |\n| `hip.integrated-multipass` | AMD GPUs (supported by ROCm) | HIP backend (clang) | ROCm >= 4.0, LLVM >= 10 |\n| `spirv` | Intel GPUs | SPIR-V/Level Zero backend | Level Zero driver and loader, clang with SYCL patches (e.g DPC++) |\n| `generic` | NVIDIA, AMD, Intel GPUs, OpenCL SPIR-V devices | Generic single-pass compiler | LLVM >= 14. When dispatching kernels to AMD hardware, ROCm >= 5.3 is recommended. When dispatching to NVIDIA, clang needs nvptx64 backend enabled. AdaptiveCpp runtime backends for the respective target hardware need to be available. |\n\n#### Models\n\n* SYCL: (No SYCL-specific requirements)\n* C++ standard parallelism: See [here](stdpar.md) for dependencies.\n\nPlease make sure to read the instructions below for the dependencies that apply to your use case.\n\n#### LLVM (skip if you only want flows without LLVM dependency)\n\nFollow [these](install-llvm.md) instructions.\n\n#### CUDA (skip if you don't need CUDA support)\n\nFollow [these](install-cuda.md) instructions\n\n#### ROCm (skip if you don't need ROCm support)\n\nFollow [these](install-rocm.md) instructions\n\n#### SPIR-V/Level Zero (skip if you don't need SPIR-V/Level Zero support)\n\nFollow [these](install-spirv.md) instructions.\n\n#### SPIR-V/OpenCL (skip if you don't need SPIR-V/OpenCL support)\n\nFollow [these](install-ocl.md) instructions.\n\n#### Building and installing \n\nOnce the software requirements mentioned above are met, clone the repository:\n```\n$ git clone https://github.com/AdaptiveCpp/AdaptiveCpp\n```\nThen, create a build directory and compile AdaptiveCpp. As described below, some backends and compilation flows must be configured with specific cmake arguments which should be passed during the cmake step.\n\n```\n$ cd <build directory>\n$ cmake -DCMAKE_INSTALL_PREFIX=<installation prefix> <more optional options, e.g. to configure the LLVM dependency> <AdaptiveCpp source directory>\n$ make install\n```\n\nThe default installation prefix is `/usr/local`. Change this to your liking.\n**Note: AdaptiveCpp needs to be installed to function correctly; don't replace \"make install\" with just \"make\"!**\n\n##### CMake options to configure the AdaptiveCpp build\n\n###### General\n*  `-DCMAKE_CXX_COMPILER` should be pointed to the C++ compiler to compile AdaptiveCpp with. Note that this also sets the default C++ compiler for the CPU backend when using acpp once AdaptiveCpp is installed. This can however also be modified later using `HIPSYCL_CPU_CXX`.\n\n###### omp.library-only\n\n* `-DCMAKE_CXX_COMPILER` can be used to set the default OpenMP compiler.\n\n###### omp.accelerated\n\n* `-DWITH_ACCELERATED_CPU=OFF/ON` can be used to explicitly disable/enable CPU acceleration. Support for CPU acceleration is enabled by default when enabling the LLVM dependency, and LLVM is sufficiently new.\n\n###### cuda.*\n\n* See the CUDA [installation instructions](install-cuda.md) instructions (section on clang).\n\n###### cuda-nvcxx\n\n* See the CUDA [installation instructions](install-cuda.md) instructions (section on nvc++).\n\n###### hip.*\n\n* See the ROCm [installation instructions](install-rocm.md) instructions.\n\n###### spirv\n\n* No specific cmake flags are currently available.\n\n## Manual installation (Mac)\n\nOn Mac, only the CPU backends are supported. The required steps are analogous to Linux.\n\n## Manual installation (Windows)\n\nFor experimental building on Windows (CPU and CUDA backends) see the corresponding [wiki](https://github.com/OpenSYCL/OpenSYCL/wiki/Using-AdaptiveCpp-on-Windows).\nThe `omp.accelerated` CPU compilation flow is unsupported on Windows.\n\n## Repositories (Linux)\n\n**Note: The software repositories mentioned below are outdated and in the process of being restructured. They do not contain modern AdaptiveCpp versions.**\n\nAnother way to install AdaptiveCpp is to use our repositories. We provide repositories for several distributions (currently Ubuntu 18.04, CentOS 7, Arch Linux). A description of the repositories is available [here](../install/scripts/README.md#installing-from-repositories)\n\nOur repositories cover the *entire software stack*, i.e. they include a compatible clang/LLVM distribution and ROCm stacks. The following packages are available:\n* `hipSYCL` - contains the actual AdaptiveCpp libraries, tools and headers\n* `hipSYCL-base` - contains the LLVM/clang stack used by AdaptiveCpp. Installation of this package is mandatory.\n* `hipSYCL-rocm` - contains a ROCm stack. This package is only required if you wish to target AMD ROCm GPUs.\n* `hipSYCL-nightly` - built from the current develop branch every day.\n* `hipSYCL-base-nightly` - contains the LLVM/clang stack for the nightly AdaptiveCpp packages\n* `hipSYCL-rocm-nightly` - contains a ROCm stack compatible with the nightly AdaptiveCpp packages\n\n**Note: For legal reasons, we do not redistribute the hipSYCL-cuda package** This package is only required if you wish to target CUDA GPUs. You will either have to create a CUDA package using `install/scripts/packaging/make-<distribution>-cuda-pkg.sh` or you can install CUDA directly using the `install/scripts/install-cuda.sh` script.\n\n\n## Installation scripts\n\n**Note: The scripts are outdated and in process of being restructured. They may or may not work with recent AdaptiveCpp versions**\nWe also provide scripts for packaging AdaptiveCpp and its dependencies. For more information on packaging and how to create your own AdaptiveCpp packages, please see the [documentation](../install/scripts/README.md).\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/installing.md"}, {"result": {"value": "# AdaptiveCpp installation instructions for ROCm\n\nPlease install ROCm 4.0 or later as described in the ROCm readme. Make sure to also install HIP (runtime libraries and headers).\n\n*Note: Newer ROCm versions may require building AdaptiveCpp against newer clang versions as well. For example, ROCm 4.5 requires clang 13+.*\n\n*Note: Instead of building AdaptiveCpp against a regular clang/LLVM, it is also possible to build AdaptiveCpp against the clang/LLVM that ships with ROCm. This can be interesting if other available clang/LLVM installations are not new enough to work with the ROCm installation.* \n* **Such configurations typically work, but are generally less tested.**\n* Also note that the LLVM distributions shipping with ROCm are not official LLVM releases, and depending on when the upstream development was last merged, may have slightly diverging functionality. There are multiple known cases where this causes problems: \n  * The clang 13 from ROCm 4.5 lacks functionality that is present in official clang 13 releases and that AdaptiveCpp's clang 13 code paths need. In that case you will need to set `-DHIPSYCL_NO_DEVICE_MANGLER=ON` when compiling AdaptiveCpp. This will however break [explicit multipass](compilation.md) support.\n  * Similarly, the clang 14 from ROCm 5.0 lacks functionality that is present in official clang 14 releases. You can work around those issues by setting `-DWITH_ACCELERATED_CPU=OFF -DWITH_SSCP_COMPILER=OFF` at the expense of reduced kernel performance on CPUs and lack of [SSCP](compilation.md) support.\n\n*Note: AdaptiveCpp is by default configured to utilize the ROCm compilation flags that apply for recent clang and ROCm versions. If you are using an older clang (<= 10) or ROCm < 4, you might have to adjust `-DROCM_CXX_FLAGS` (not recommended!).*\n\nCMake variables:\n* `-DROCM_PATH=/path/to/rocm` (default: /opt/rocm)\n* `-DWITH_ROCM_BACKEND=ON` if AdaptiveCpp does not automatically enable the ROCm backend \n* `-DHIPSYCL_NO_DEVICE_MANGLER=OFF/ON` *if and only if* you build against ROCm's clang and hit the issue that it lacks functionality that regular clang 13 provides, and you cannot build AdaptiveCpp otherwise. This *will* break [explicit multipass](compilation.md) support, i.e. you will not be able to compile for multiple device backends simultaneously.\n\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-rocm.md"}, {"result": {"value": "* [Building & Installing](doc/installing.md)\n\nIn order to compile software with AdaptiveCpp, use `acpp`. `acpp` can be used like a regular compiler, i.e. you can use `acpp -o test test.cpp` to compile your application called `test.cpp` with AdaptiveCpp.\n\n`acpp` accepts both command line arguments and environment variables to configure its behavior (e.g., to select the target to compile for). See `acpp --help` for a comprehensive list of options.\n\nWhen compiling with AdaptiveCpp, you will need to specify the targets you wish to compile for using the `--acpp-targets=\"compilation-flow1:target1,target2,...;compilation-flow2:...\"` command line argument, `ACPP_TARGETS` environment variable or cmake argument. See the documentation on [using AdaptiveCpp](doc/using-hipsycl.md) for details. When in doubt, use `--acpp-targets=generic` which will generate a binary that can run on any supported offload device. If parallel kernel execution on CPU is also needed, use `--acpp-targets=\"omp;generic\"`.\n\nInstructions for using AdaptiveCpp in CMake projects can also be found in the documentation on [using AdaptiveCpp](doc/using-hipsycl.md).\n", "type": "Text_excerpt", "original_header": "Installing and using AdaptiveCpp", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "usage": [{"result": {"value": "Join us on [Discord](https://discord.gg/s2p7Vccwh3)!\nAlternatively, open a discussion or issue in this repository.\n", "type": "Text_excerpt", "original_header": "Getting in touch", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "citation": [{"result": {"value": "AdaptiveCpp is a research project. As such, if you use AdaptiveCpp in your research, we kindly request that you cite one of the following publications, depending on your focus:\n\n* A general overview, SYCL 2020, performance and the relationship with oneAPI: *Aksel Alpay, B\u00e1lint Soproni, Holger W\u00fcnsche, and Vincent Heuveline. 2022. Exploring the possibility of a hipSYCL-based implementation of oneAPI. In International Workshop on OpenCL (IWOCL'22). Association for Computing Machinery, New York, NY, USA, Article 10, 1\u201312. https://doi.org/10.1145/3529538.3530005*\n* The generic single-pass compiler: *Aksel Alpay and Vincent Heuveline. 2023. One Pass to Bind Them: The First Single-Pass SYCL Compiler with Unified Code Representation Across Backends. In Proceedings of the 2023 International Workshop on OpenCL (IWOCL '23). Association for Computing Machinery, New York, NY, USA, Article 7, 1\u201312. https://doi.org/10.1145/3585341.3585351*\n* Our CPU compiler: *Joachim Meyer, Aksel Alpay, Sebastian Hack, Holger Fr\u00f6ning, and Vincent Heuveline. 2023. Implementation Techniques for SPMD Kernels on CPUs. In Proceedings of the 2023 International Workshop on OpenCL (IWOCL '23). Association for Computing Machinery, New York, NY, USA, Article 1, 1\u201312. https://doi.org/10.1145/3585341.3585342*\n* The original talk and the idea of implementing SYCL on non-OpenCL backends: *Aksel Alpay and Vincent Heuveline. 2020. SYCL beyond OpenCL: The architecture, current state and future direction of hipSYCL. In Proceedings of the International Workshop on OpenCL (IWOCL \u201920). Association for Computing Machinery, New York, NY, USA, Article 8, 1. DOI:https://doi.org/10.1145/3388333.3388658*\n\n(The latter is a talk and available [online](https://www.youtube.com/watch?v=kYrY80J4ZAs). Note that some of the content in this talk is outdated by now)\n", "type": "Text_excerpt", "original_header": "Citing AdaptiveCpp", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "acknowledgement": [{"result": {"value": "We gratefully acknowledge [contributions](https://github.com/illuhad/hipSYCL/graphs/contributors) from the community.\n", "type": "Text_excerpt", "original_header": "Acknowledgements", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "support": [{"result": {"value": "Supported hardware:\n* Any CPU for which a C++17 OpenMP compiler exists\n* NVIDIA CUDA GPUs. Note that clang, which AdaptiveCpp relies on, may not always support the very latest CUDA version which may sometimes impact support for *very* new hardware. See the [clang documentation](https://www.llvm.org/docs/CompileCudaWithLLVM.html) for more details.\n* AMD GPUs that are [supported by ROCm](https://github.com/RadeonOpenCompute/ROCm#hardware-support)\n\nOperating system support currently strongly focuses on Linux. On Mac, only the CPU backend is expected to work. Windows support with CPU and CUDA backends is experimental, see [Using AdaptiveCpp on Windows](https://github.com/OpenSYCL/OpenSYCL/wiki/Using-Open-SYCL-on-Windows).\n", "type": "Text_excerpt", "original_header": "Hardware and operating system support", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "documentation": [{"result": {"value": "* AdaptiveCpp [design and architecture](doc/architecture.md)\n* AdaptiveCpp runtime [specification](doc/runtime-spec.md)\n* AdaptiveCpp [compilation model](doc/compilation.md)\n* How to use raw HIP/CUDA inside AdaptiveCpp code to create [optimized code paths](doc/hip-source-interop.md)\n* A simple SYCL example code for testing purposes can be found [here](doc/examples.md).\n* [SYCL Extensions implemented in AdaptiveCpp](doc/extensions.md)\n* [Macros used by AdaptiveCpp](doc/macros.md)\n* [Environment variables supported by AdaptiveCpp](doc/env_variables.md)\n\n\n\n", "type": "Text_excerpt", "original_header": "Documentation", "parent_header": ["AdaptiveCpp (formerly known as hipSYCL / Open SYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "full_title": [{"result": {"type": "String", "value": "AdaptiveCpp (formerly known as hipSYCL / Open SYCL)"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "logo": [{"result": {"type": "Url", "value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop//doc/img/logo/logo-color.png"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "image": [{"result": {"type": "Url", "value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop//doc/img/stack.png"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}]}