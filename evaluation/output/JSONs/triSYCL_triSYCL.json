{"somef_provenance": {"somef_version": "0.9.4", "somef_schema_version": "1.0.0", "date": "2023-12-21 18:55:42"}, "code_repository": [{"result": {"value": "https://github.com/triSYCL/triSYCL", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "owner": [{"result": {"value": "triSYCL", "type": "Organization"}, "confidence": 1, "technique": "GitHub_API"}], "date_created": [{"result": {"value": "2014-04-19T15:19:51Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "date_updated": [{"result": {"value": "2023-12-20T03:08:04Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "license": [{"result": {"value": null, "type": "License", "name": "Other", "url": null, "spdx_id": "NOASSERTION"}, "confidence": 1, "technique": "GitHub_API"}], "description": [{"result": {"value": " Generic system-wide modern C++ for heterogeneous platforms with SYCL from Khronos Group", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "triSYCL_ is a research project to experiment with the specification of\nthe SYCL_ standard and to give feedback to the Khronos_ Group", "type": "Text_excerpt", "original_header": "Introduction"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": "See `<tests/acap>`_ for some code samples. \n", "original_header": "ACAP++: C++ extensions for AMD Versal ACAP AIE1 architecture"}, "confidence": 0.8911852808018449, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": "Because of lack of resources **this SYCL implementation is very\nincomplete and should not be used by a normal end-user.** Fortunately\nthere are now many other implementations of SYCL_ available, including\nsome strong implementations like ComputeCpp_, `DPC++`_ or hipSYCL_\nthat can be used on various targets. \nThis implementation is mainly based on C++23 features backed with\nOpenMP_ or TBB_ for parallel execution on the CPU, with\n`Boost.Compute`_ for the non single-source OpenCL_ interoperability\nlayer and with an experimental LLVM_/Clang_ version for the device\ncompiler (from 2017-2018 which is now obsolete) providing full\nsingle-source SYCL_ experience, typically targeting a SPIR_\ndevice. Since in SYCL_ there is a host fall-back, this CPU\nimplementation can be seen as an implementation of this fall-back too. \nSince around 2018 Intel has put a lot of effort in their own oneAPI\n`DPC++`_ SYCL_ project to up-stream SYCL_ into LLVM_/Clang_, there is\nanother project about merging the oneAPI `DPC++`_ SYCL_ implementation\nwith triSYCL_ at https://github.com/triSYCL/sycl to give a greater\nuser experience for Xilinx_ FPGA instead of using our obsolete\nexperimental clunky device compiler. But this is still very\nexperimental because the Xilinx_ tool-chain is based on old\nincompatible versions of LLVM_/Clang_ and nothing of these is\nsupported by the Xilinx_ product teams. \nMost of our efforts are focused on extensions, such as targeting\nXilinx_ FPGA and Versal ACAP CGRA with internal developments on\nhttps://gitenterprise.xilinx.com/rkeryell/acappp. \n\ntriSYCL_ has been used to experiment and provide feedback for SYCL_\n1.2, 1.2.1, 2.2, 2020 and even the OpenCL_ C++ 1.0 kernel language\nfrom OpenCL_ 2.2. \nThis is provided as is, without any warranty, with the same license as\nLLVM_/Clang_. \nIt is possible to have a paid internship around triSYCL, if you have\nsome skills related to this project. Contact the technical lead about\nthis. AMD_ is also hiring in this area... :-) \nSYCL_ is a single-source modern C++-based DSEL_ (Domain Specific\nEmbedded Language) and open standard from Khronos_ aimed at\nfacilitating the programming of heterogeneous accelerators by\nleveraging existing concepts inspired by OpenCL_, CUDA_, `C++AMP`_, OpenMP_... \nNote that even if the concepts behind SYCL_ are inspired by OpenCL_\nconcepts, the SYCL_ programming model is a very general asynchronous\ntask graph model for heterogeneous computing targeting various\nframeworks and API and has *no* relation with OpenCL_ itself, except\nwhen using the OpenCL_ API interoperability mode, like any other\ntarget. \n", "original_header": "SYCL"}, "confidence": 0.9375161534831444, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": "- 2023/06/09: merge the 5-year old branch experimenting with ACAP++\n  SYCL CPU model extensions for AMD Versal ACAP AIE1 CGRA like the\n  XCVC1902 used in VCK190 or VCK5000 boards. \n- 2018/03/12: the long-going device compiler branch has been merged in\n  to provide experimental support for SPIR-df friendly devices, such\n  as PoCL_ or Xilinx_ FPGA. This is only for the brave for now. \n- 2018/02/01: there is now some documentation about the architecture of\n  triSYCL on GPU and accelerators with its device compiler based on\n  Clang_/LLVM_ in `<doc/architecture.rst>`_. While this is wildly\n  experimental, there is a growing interest around it and it is\n  always useful to get started as a contributor. \n- 2018/01/05: there are some internship openings at Xilinx_ to work on\n  triSYCL for FPGA\n  https://xilinx.referrals.selectminds.com/jobs/compiler-engineer-intern-on-sycl-for-fpga-4685\n  and more generally Xilinx_ is hiring in compilation, runtime, C++,\n  SYCL_, OpenCL_, machine-learning... \n- 2017/12/06: the brand-new SYCL 1.2.1 specification is out and\n  triSYCL starts moving to it \n- 2017/09/19: there is a prototype of device compiler based on\n  Clang_/LLVM_ generating SPIR 2.0 \"de facto\" (SPIR-df) and working at least\n  with PoCL_ and Xilinx_ SDx `xocc` for FPGA. \n  So manual inline of the following everywhere... :-( \n", "original_header": "News"}, "confidence": 0.9487327009372392, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": "..\n  Not supported by GitHub :-(\n  include:: doc/common-includes.rst \n"}, "confidence": 0.8179406581723889, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}], "name": [{"result": {"value": "triSYCL", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "full_name": [{"result": {"value": "triSYCL/triSYCL", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "issue_tracker": [{"result": {"value": "https://api.github.com/repos/triSYCL/triSYCL/issues", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "forks_url": [{"result": {"value": "https://api.github.com/repos/triSYCL/triSYCL/forks", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "stargazers_count": [{"result": {"value": 429, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "keywords": [{"result": {"value": "cpp, cpp20, fpga, gpu-computing, heterogeneous-parallel-programming, opencl, spir, sycl, trisycl", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "forks_count": [{"result": {"value": 98, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "download_url": [{"result": {"value": "https://github.com/triSYCL/triSYCL/releases", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "programming_languages": [{"result": {"value": "C++", "name": "C++", "type": "Programming_language", "size": 1337744}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "C", "name": "C", "type": "Programming_language", "size": 924043}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "CMake", "name": "CMake", "type": "Programming_language", "size": 49902}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Makefile", "name": "Makefile", "type": "Programming_language", "size": 21437}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Shell", "name": "Shell", "type": "Programming_language", "size": 4458}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Emacs Lisp", "name": "Emacs Lisp", "type": "Programming_language", "size": 368}, "confidence": 1, "technique": "GitHub_API"}], "readme_url": [{"result": {"value": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "documentation": [{"result": {"value": "Some reasons to use SYCL\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nPlease see `about SYCL <doc/about-sycl.rst>`_ to have some context, a\nlist of presentations, some related projects.\n\n\nInstallation & testing\n~~~~~~~~~~~~~~~~~~~~~~\n\nSYCL_ is a template library, so no real installation is required.\n\nThere are some examples you can build however.\n\nSee `Testing <doc/testing.rst>`_.\n\n\nArchitecture of triSYCL runtime and compiler\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`Architecture of triSYCL runtime and compiler <doc/architecture.rst>`_\ndescribes the code base with some high-level diagrams but also how it\nwas possible to compile and use the obsolete device compiler on some Xilinx_\nFPGA for example. Now look at https://github.com/triSYCL/sycl instead.\n\n\nCMake infrastructure\n~~~~~~~~~~~~~~~~~~~~\n\nSome details about CMake configuration and organization can be found\nin `CMake <doc/cmake.rst>`_.\n\n\nPre-processor macros used in triSYCL\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYes, there are some macros used in triSYCL! Look at `Pre-processor\nmacros used in triSYCL <doc/macros.rst>`_ to discover some of them.\n\n\nEnvironment variables used in triSYCL\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSee `Environment variables with triSYCL <doc/environment.rst>`_.\n\n\nPossible futures\n~~~~~~~~~~~~~~~~\n\nSee `Possible futures <doc/possible-futures.rst>`_.\n\n\ntriSYCL code documentation\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe documentation of the triSYCL_ implementation itself can be found\nin https://trisycl.github.io/triSYCL/Doxygen/triSYCL/html and\nhttps://trisycl.github.io/triSYCL/Doxygen/triSYCL/triSYCL-implementation-refman.pdf\n\nThere are also some internal documentation at\nhttps://pages.gitenterprise.xilinx.com/rkeryell/acappp/Doxygen/acappp/html\n\n", "type": "Text_excerpt", "original_header": "Documentation"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Url", "value": "https://github.com/triSYCL/triSYCL/wiki", "format": "wiki"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}], "installation": [{"result": {"type": "Text_excerpt", "value": "Look at `<doc/acap.rst>`_ to know more about how to install/use the\nACAP++ environment. \n", "original_header": "ACAP++: C++ extensions for AMD Versal ACAP AIE1 architecture"}, "confidence": 0.8111449861815457, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": "- 2016/11/18: If you missed the free SYCL_ T-shirt on the Khronos booth\n  during SC16_, you can always buy some on\n  https://teespring.com/khronos-hpc (lady's sizes available, so no\n  excuse! :-) ) \n.. _Bolt: https://github.com/HSA-Libraries/Bolt \n.. _CLHPP: https://github.com/KhronosGroup/OpenCL-CLHPP \n.. _CUDA: https://developer.nvidia.com/cuda-zone \n.. _DPC++: https://github.com/intel/llvm/tree/sycl \n.. _GCC: https://gcc.gnu.org/ \n.. _HCC: https://github.com/RadeonOpenCompute/hcc \n.. _HIP: https://github.com/ROCm-Developer-Tools/HIP \n.. _hipSYCL: https://github.com/illuhad/hipSYCL \n.. _triSYCL: https://github.com/triSYCL/triSYCL \n", "original_header": "News"}, "confidence": 0.8827886126677342, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}], "invocation": [{"result": {"type": "Text_excerpt", "value": "  queue {}.submit([&](handler &h) {\n      auto accA = bufA.get_access<access::mode::read>(h);\n      auto accB = bufB.get_access<access::mode::write>(h);\n      h.parallel_for<class myKernel>(myRange, [=](item i) {\n          accA[i] = accB[i] + 1;\n      });\n  }); \n", "original_header": "SYCL"}, "confidence": 0.855604911877261, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}], "full_title": [{"result": {"type": "String", "value": ""}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/triSYCL/triSYCL/master/README.rst"}]}