{"somef_provenance": {"somef_version": "0.9.4", "somef_schema_version": "1.0.0", "date": "2023-12-21 19:11:28"}, "code_repository": [{"result": {"value": "https://github.com/renatahodovan/picire", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "owner": [{"result": {"value": "renatahodovan", "type": "User"}, "confidence": 1, "technique": "GitHub_API"}], "date_created": [{"result": {"value": "2016-05-13T14:31:38Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "date_updated": [{"result": {"value": "2023-08-16T20:02:50Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "license": [{"result": {"value": null, "type": "License", "name": "Other", "url": null, "spdx_id": "NOASSERTION"}, "confidence": 1, "technique": "GitHub_API"}], "description": [{"result": {"value": "Parallel Delta Debugging Framework", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Text_excerpt", "value": "Just like the original algorithm, *Picire* automatically reduces \"interesting\"\ntests while keeping their \"interesting\" behaviour. A common use case is\nminimizing failing tests so that they still reproduce the original failure. \nThe tool (and the algorithm) works iteratively. As a first step, it splits up\nthe input into *n* chunks either by lines or characters. Then, iteratively,\nit inspects smaller test cases composed of these chunks whether they are still\ninteresting. The selection of chunks can happen two ways: either a small subset\nof the chunks is kept (subset-based reduce), or that small subset is removed\nand everything else is kept (complement-based reduce). If a new interesting\ntest case is found, it becomes the input of the next iteration. The iterations\nstop if removing any further chunks would make the test uninteresting (e.g. the\ntest is **1-minimal**). \n"}, "confidence": 0.8793174054922626, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "name": [{"result": {"value": "picire", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "full_name": [{"result": {"value": "renatahodovan/picire", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "issue_tracker": [{"result": {"value": "https://api.github.com/repos/renatahodovan/picire/issues", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "forks_url": [{"result": {"value": "https://api.github.com/repos/renatahodovan/picire/forks", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "stargazers_count": [{"result": {"value": 45, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "keywords": [{"result": {"value": "delta-debugging, hacktoberfest, test-automation, test-reduction", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "forks_count": [{"result": {"value": 9, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "download_url": [{"result": {"value": "https://github.com/renatahodovan/picire/releases", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "programming_languages": [{"result": {"value": "Python", "name": "Python", "type": "Programming_language", "size": 65975}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Batchfile", "name": "Batchfile", "type": "Programming_language", "size": 324}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Shell", "name": "Shell", "type": "Programming_language", "size": 313}, "confidence": 1, "technique": "GitHub_API"}], "readme_url": [{"result": {"value": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "has_script_file": [{"result": {"value": "https://raw.githubusercontent.com/renatahodovan/picire/master/tests/resources/test-json-extra-comma.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/renatahodovan/picire/master/tests/resources/test-json-invalid-escape.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/renatahodovan/picire/master/tests/resources/test-sumprod10-prod.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/renatahodovan/picire/master/tests/resources/test-sumprod10-sum.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "requirements": [{"result": {"value": "* Python_ >= 3.7\n\n.. _Python: https://www.python.org\n\n", "type": "Text_excerpt", "original_header": "Requirements"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "installation": [{"result": {"value": "To use *Picire* in another project, it can be added to ``setup.cfg`` as an\ninstall requirement (if using setuptools_ with declarative config):\n\n.. code-block:: ini\n\n    [options]\n    install_requires =\n        picire\n\nTo install *Picire* manually, e.g., into a virtual environment, use pip_::\n\n    pip install picire\n\nThe above approaches install the latest release of *Picire* from PyPI_.\nAlternatively, for the development version, clone the project and perform a\nlocal install::\n\n    pip install .\n\n.. _setuptools: https://github.com/pypa/setuptools\n.. _pip: https://pip.pypa.io\n.. _PyPI: https://pypi.org/\n\n", "type": "Text_excerpt", "original_header": "Install"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}, {"result": {"type": "Text_excerpt", "value": ".. image:: https://img.shields.io/pypi/v/picire?logo=python&logoColor=white\n   :target: https://pypi.org/project/picire/\n.. image:: https://img.shields.io/pypi/l/picire?logo=open-source-initiative&logoColor=white\n   :target: https://pypi.org/project/picire/\n.. image:: https://img.shields.io/github/actions/workflow/status/renatahodovan/picire/main.yml?branch=master&logo=github&logoColor=white\n   :target: https://github.com/renatahodovan/picire/actions\n.. image:: https://img.shields.io/coveralls/github/renatahodovan/picire/master?logo=coveralls&logoColor=white\n   :target: https://coveralls.io/github/renatahodovan/picire \n"}, "confidence": 0.8641954991554377, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "usage": [{"result": {"value": "*Picire* has two mandatory command line arguments: one that defines the input\ntest case to be reduced (``--input``) and another describing an executable\ntester script or program (``--test``) that can decide about the interestingness\nof an arbitrary input. This will be run in every iteration to check a test case.\n", "type": "Text_excerpt", "original_header": "Usage"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}, {"result": {"value": "* ``--parallel``: Enables *Picire* to run in multiprocess mode. (Otherwise, the\n  original single-process variant will run.)\n\n* ``-j <num>``: Defines the maximum number of parallel jobs.\n\n* ``--complement-first``: For some input types, subset-based reduce is not as\n  effective as the complement-based one (sometimes, aggressively removing too\n  big parts of the input eliminates the interestingness as well). By default,\n  *Picire* performs subset-based reduce before complement-based reduce, which\n  can result in many superfluous checks for such inputs. This flag forces to\n  start with complement checks.\n\n* ``--subset-iterator`` / ``--complement-iterator``: Guide the iteration\n  strategies of the subset and complement-based reduce loops.\n\n  * ``forward``: Start investigating subsets (or complements) from the beginning\n    of the input.\n\n  * ``backward``: Start investigating subsets (or complements) from the end of\n    the input. The goal is to reduce the number of semantic violations\n    (assuming that definitions - like variable declarations - appear before\n    uses).\n\n  * ``skip``: Completely avoids the subset or complement checks (mostly used\n    with ``--subset-iterator``).\n\nFor the detailed options, see ``picire --help``.\n", "type": "Text_excerpt", "original_header": "Common settings", "parent_header": ["Usage"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}, {"result": {"value": "The tester script is expected to take one command line argument, the path of a\ntest case, and it has to exit with 0 if the test is interesting and with\nnon-zero otherwise. An example tester script that runs an arbitrary target\napplication and checks if it fails on an assertion might look like the one\nbelow::\n\n    #! /bin/bash\n    timeout --foreground 10 <path/to/the/target/application> $1 2>&1 | grep -q \"Assertion failed\";\n\n**Remarks:**\n\n* The ``<path/to/the/target/application>`` should either be an absolute path to\n  the target application or the application should be on the search path (i.e.,\n  ``$PATH``).\n* ``$1`` is the single and mandatory command line argument containing the path\n  of a test case.\n* If the target application is not guaranteed to exit, then it's worth running\n  it with ``timeout`` to limit the amount of time waiting for producing the\n  expected behaviour.\n* If the target is run with timeout then the ``--foreground`` flag can also be\n  useful as it allows forwarding the ``KILL`` signals (used by the parallel\n  implementation) through the timeout's process group. This enables us to\n  stop all alive parallel processes when a new interesting configuration\n  is found already.\n* If the interestingness decision is based on the content of the output then\n  using ``grep`` (perhaps with ``-q`` or ``--quiet``) might be a right choice,\n  since it returns 0 if the pattern was found and 1 if not. Exactly the\n  return value *Picire* expects.\n\nA common form of *Picire*'s usage::\n\n    picire --input=<path/to/the/input> --test=<path/to/the/tester> \\\n           --parallel --subset-iterator=skip --complement-iterator=backward\n\n", "type": "Text_excerpt", "original_header": "Tester script", "parent_header": ["Usage"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "acknowledgement": [{"result": {"value": "This software uses the delta debugging algorithm as described in:\n\n* Andreas Zeller. Yesterday, My Program Worked. Today, It Does Not. Why?\n  In Proceedings of the 7th European Software Engineering Conference Held\n  Jointly with the 7th ACM SIGSOFT Symposium on the Foundations of Software\n  Engineering (ESEC/FSE '99), volume 1687 of Lecture Notes in Computer Science\n  (LNCS), pages 253-267, Toulouse, France, September 1999. Springer.\n  https://doi.org/10.1007/3-540-48166-4_16\n* Ralf Hildebrandt and Andreas Zeller. Simplifying Failure-Inducing Input.\n  In Proceedings of the 2000 ACM SIGSOFT International Symposium on Software\n  Testing and Analysis (ISSTA '00), pages 135-145, Portland, Oregon, USA, August\n  2000. ACM.\n  https://doi.org/10.1145/347324.348938\n\nFurther improvements are described in:\n\n* Renata Hodovan and Akos Kiss. Practical Improvements to the Minimizing Delta\n  Debugging Algorithm.\n  In Proceedings of the 11th International Joint Conference on Software\n  Technologies (ICSOFT 2016) - Volume 1: ICSOFT-EA, pages 241-248, Lisbon,\n  Portugal, July 2016. SciTePress.\n  https://doi.org/10.5220/0005988602410248\n* Renata Hodovan, Akos Kiss, and Tibor Gyimothy. Tree Preprocessing and Test\n  Outcome Caching for Efficient Hierarchical Delta Debugging.\n  In Proceedings of the 12th IEEE/ACM International Workshop on Automation of\n  Software Testing (AST 2017), pages 23-29, Buenos Aires, Argentina, May 2017.\n  IEEE.\n  https://doi.org/10.1109/AST.2017.4\n* Akos Kiss. Generalizing the Split Factor of the Minimizing Delta Debugging\n  Algorithm.\n  IEEE Access, 8:219837-219846, December 2020. IEEE.\n  https://doi.org/10.1109/ACCESS.2020.3043027\n* Daniel Vince. Iterating the Minimizing Delta Debugging Algorithm.\n  In Proceedings of the 13th International Workshop on Automating Test Case\n  Design, Selection and Evaluation (A-TEST'22), pages 57-60, Singapore, November\n  2022. ACM.\n  https://doi.org/10.1145/3548659.3561314\n* Daniel Vince and Akos Kiss. Cache Optimizations for Test Case Reduction.\n  In Proceedings of the 22nd IEEE International Conference on Software Quality,\n  Reliability, and Security (QRS 2022), pages 442-453, Guangzhou, China,\n  December 2022. IEEE.\n  https://doi.org/10.1109/QRS57517.2022.00052\n\n", "type": "Text_excerpt", "original_header": "Acknowledgement and Citations"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "citation": [{"result": {"value": "This software uses the delta debugging algorithm as described in:\n\n* Andreas Zeller. Yesterday, My Program Worked. Today, It Does Not. Why?\n  In Proceedings of the 7th European Software Engineering Conference Held\n  Jointly with the 7th ACM SIGSOFT Symposium on the Foundations of Software\n  Engineering (ESEC/FSE '99), volume 1687 of Lecture Notes in Computer Science\n  (LNCS), pages 253-267, Toulouse, France, September 1999. Springer.\n  https://doi.org/10.1007/3-540-48166-4_16\n* Ralf Hildebrandt and Andreas Zeller. Simplifying Failure-Inducing Input.\n  In Proceedings of the 2000 ACM SIGSOFT International Symposium on Software\n  Testing and Analysis (ISSTA '00), pages 135-145, Portland, Oregon, USA, August\n  2000. ACM.\n  https://doi.org/10.1145/347324.348938\n\nFurther improvements are described in:\n\n* Renata Hodovan and Akos Kiss. Practical Improvements to the Minimizing Delta\n  Debugging Algorithm.\n  In Proceedings of the 11th International Joint Conference on Software\n  Technologies (ICSOFT 2016) - Volume 1: ICSOFT-EA, pages 241-248, Lisbon,\n  Portugal, July 2016. SciTePress.\n  https://doi.org/10.5220/0005988602410248\n* Renata Hodovan, Akos Kiss, and Tibor Gyimothy. Tree Preprocessing and Test\n  Outcome Caching for Efficient Hierarchical Delta Debugging.\n  In Proceedings of the 12th IEEE/ACM International Workshop on Automation of\n  Software Testing (AST 2017), pages 23-29, Buenos Aires, Argentina, May 2017.\n  IEEE.\n  https://doi.org/10.1109/AST.2017.4\n* Akos Kiss. Generalizing the Split Factor of the Minimizing Delta Debugging\n  Algorithm.\n  IEEE Access, 8:219837-219846, December 2020. IEEE.\n  https://doi.org/10.1109/ACCESS.2020.3043027\n* Daniel Vince. Iterating the Minimizing Delta Debugging Algorithm.\n  In Proceedings of the 13th International Workshop on Automating Test Case\n  Design, Selection and Evaluation (A-TEST'22), pages 57-60, Singapore, November\n  2022. ACM.\n  https://doi.org/10.1145/3548659.3561314\n* Daniel Vince and Akos Kiss. Cache Optimizations for Test Case Reduction.\n  In Proceedings of the 22nd IEEE International Conference on Software Quality,\n  Reliability, and Security (QRS 2022), pages 442-453, Guangzhou, China,\n  December 2022. IEEE.\n  https://doi.org/10.1109/QRS57517.2022.00052\n\n", "type": "Text_excerpt", "original_header": "Acknowledgement and Citations"}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}], "full_title": [{"result": {"type": "String", "value": "Requirements"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/renatahodovan/picire/master/README.rst"}]}